{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2022-10-20T10:49:38.000Z","updated":"2022-10-20T10:51:55.299Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-20T10:49:46.000Z","updated":"2022-10-20T10:51:45.989Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"性能测试_loadrunner","slug":"软件测试/性能测试-loadrunner","date":"2022-10-22T04:07:48.000Z","updated":"2022-10-25T11:15:13.812Z","comments":true,"path":"2022/10/22/软件测试/性能测试-loadrunner/","link":"","permalink":"http://example.com/2022/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-loadrunner/","excerpt":"","text":"LoadRunner_01 LoadRunner_02 loadrunner 介绍 LoadRunner_03 LoadRunner_04 loadrunner特性 LoadRunner_05 LoadRunner_06 loadrnnergo工作原理 LoadRunner_07 LoadRunner_08 LoadRunner_09 LoadRunner_10 LoadRunner_11 loadrunner工作过程 LoadRunner_12 LoadRunner_13 LoadRunner_14 loadrunner测试步骤 LoadRunner_15 LoadRunner_16 LoadRunner_17 LoadRunner_18 LoadRunner_19 LoadRunner_20 VuGen LoadRunner_21 LoadRunner_22 LoadRunner_23 LoadRunner_24 LoadRunner_25 脚本开发过程 LoadRunner_26 新建脚本 LoadRunner_27 LoadRunner_28 如何选择协议 LoadRunner_29 LoadRunner_30 录制原理 LoadRunner_31 LoadRunner_32 脚本录制 LoadRunner_33 录制选项 LoadRunner_34 LoadRunner_35 LoadRunner_36 LoadRunner_37 LoadRunner_38 LoadRunner_39 LoadRunner_40 工具栏 LoadRunner_41 录制完成后的查看录制结果中（在最下面），可以更改录制后的地址信息，更改后在重构 代理录制 LoadRunner_42 LoadRunner_43 LoadRunner_44 回放脚本 LoadRunner_45 LoadRunner_46 运行时设置 LoadRunner_47 LoadRunner_48 迭代次数 LoadRunner_49 时间间隔 LoadRunner_50 LoadRunner_51 日志 LoadRunner_52 LoadRunner_53 思考时间 LoadRunner_54 LoadRunner_55 回放选项 LoadRunner_56 LoadRunner_57 LoadRunner_58 思考时间 LoadRunner_59 LoadRunner_60 LoadRunner_61 检查点 LoadRunner_62 LoadRunner_63 LoadRunner_64 LoadRunner_65 检查点函数时注册型 函数 一定要将函数放在 请求的前面 检查点查找的服务器返回的信息 web add header 是添加表头信息的东西，算在之后好一点 参数化 LoadRunner_66 参数化方法 LoadRunner_67 LoadRunner_68 LoadRunner_69 LoadRunner_70 数据分配方式 LoadRunner_71 LoadRunner_72 LoadRunner_73 LoadRunner_74 LoadRunner_75 数据更新方式 LoadRunner_76 LoadRunner_77 数据分配和数据更新组合 LoadRunner_78 数据分配和数据更新应用 LoadRunner_79 LoadRunner_80 LoadRunner_81 随机数 LoadRunner_82 LoadRunner_83 唯一数 LoadRunner_84 LoadRunner_85 LoadRunner_86 日期时间 LoadRunner_87 LoadRunner_88 关联 LoadRunner_89 LoadRunner_90 web_reg_save_param_ex() LoadRunner_91 LoadRunner_92 web_reg_save_param() LoadRunner_93 LoadRunner_94 web_reg_save_param_regexp() LoadRunner_95 LoadRunner_96 集合点 LoadRunner_97 LoadRunner_98 LoadRunner_99 事务 LoadRunner_100 LoadRunner_101 LoadRunner_102 事务中有思考时间 要去掉 Controller LoadRunner_103 LoadRunner_104 LoadRunner_105 场景创建 LoadRunner_106 LoadRunner_107 LoadRunner_108 LoadRunner_109 场景分类 LoadRunner_110 人工场景 LoadRunner_111 用户分配方式 LoadRunner_112 LoadRunner_113 Scenario Groups LoadRunner_114 LoadRunner_115 LoadRunner_116 LoadRunner_117 LoadRunner_118 LoadRunner_119 LoadRunner_120 LoadRunner_121 LoadRunner_122 集合点 LoadRunner_123 LoadRunner_124 LoadRunner_125 LoadRunner_126 LoadRunner_127 Load Generator负载发生器 LoadRunner_128 LoadRunner_129 Scenario schedule LoadRunner_130 LoadRunner_131 LoadRunner_132 LoadRunner_133 计划操作 LoadRunner_134 LoadRunner_135 LoadRunner_136 LoadRunner_137 LoadRunner_138 LoadRunner_139 LoadRunner_140 LoadRunner_141 面向目标场景 LoadRunner_142 LoadRunner_143 LoadRunner_144 Scenario Settings LoadRunner_145 Load Behavior LoadRunner_146 Goal Type LoadRunner_147 LoadRunner_148 LoadRunner_149 LoadRunner_150 LoadRunner_151 运行原理 LoadRunner_152 LoadRunner_153 场景运行场景控制 LoadRunner_154 LoadRunner_155 LoadRunner_156 LoadRunner_157 场景查看Vuesr运行状态 LoadRunner_158 LoadRunner_159 事务详细信息 LoadRunner_160 LoadRunner_161 LoadRunner_162 查看Output窗口 LoadRunner_163 LoadRunner_164 场景监控 LoadRunner_165 监控器类型 LoadRunner_166 LoadRunner_167 监视器设置 LoadRunner_168 LoadRunner_169 LoadRunner_170 视图配置 LoadRunner_171 LoadRunner_172 Analysis LoadRunner_173 LoadRunner_174 Analysis基础知识 LoadRunner_175 LoadRunner_176 LoadRunner_177 设置选项 LoadRunner_178 Result Collection LoadRunner_179 LoadRunner_180 LoadRunner_181 LoadRunner_182 LoadRunner_183 LoadRunner_184 Set Granularity(设置粒度) LoadRunner_185 LoadRunner_186 Configure Measurements LoadRunner_187 设置筛选条件 LoadRunner_188 LoadRunner_189 Analysis图 LoadRunner_190 LoadRunner_191 LoadRunner_192 LoadRunner_193 LoadRunner_194 Analysis报告 LoadRunner_195 摘要报告 LoadRunner_196 LoadRunner_197 LoadRunner_198 LoadRunner_199 LoadRunner_200 LoadRunner_201 HTML报告 LoadRunner_202 事务分析报告 LoadRunner_203 LoadRunner_204 LoadRunner_205 LoadRunner_206 LoadRunner_207 LoadRunner_208 LoadRunner_209 新建报告 LoadRunner_210 LoadRunner_211 LoadRunner_212","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"软件测试/性能测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"性能测试","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"jmeter","slug":"jmeter","permalink":"http://example.com/tags/jmeter/"}]},{"title":"软件测试考点","slug":"软件测试/软件测试考点","date":"2022-10-22T03:39:37.000Z","updated":"2022-10-22T03:47:54.534Z","comments":true,"path":"2022/10/22/软件测试/软件测试考点/","link":"","permalink":"http://example.com/2022/10/22/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%80%83%E7%82%B9/","excerpt":"","text":"单元测试1）语句覆盖法、2）判定覆盖法、3）条件覆盖法、4）判定条件覆盖法、5）条件组合覆盖法、6）路径覆盖法、7）基本路径覆盖法、8）JUnit基础注解、9）JUnit assert断言方法、10）JUnit assertThat一般匹配符断言、11）JUnit assertThat字符串相关匹配符断言、12）JUnit assertThat数值相关匹配符断言、13）JUnit assertThat集合相关匹配符断言、14）JUnit参数化设置、15）JUnit测试套件、16）JUnit测试优先级顺序、17）JUnit TestRunner使用、18）JUnit内置Rule中TestName使用、19）JUnit内置Rule中TemporaryFolder使用、20）JUnit内置Rule中ExternalResource使用、21）JUnit测试private方法。 测试文档1）编写目的、2）项目背景、3）测试目的、4）测试参考文档、5）测试范围、6）测试提交文档。7）软件配置、8）硬件配置、9）人力资源分配、10）整体测试计划设计、11）相关风险、12）项目组成员、13）整体测试实施情况、14）测试结论 测试用例、BUG自动化测试1、自动化测试功能点选取范围 1）用户登录、2）用户退出、3）个人信息、4）部门管理、5）人员管理、6）资产类别、7）品牌、8）取得方式、9）供应商、10）存放地点、11）设备用途、12）报废方式、13）资产申购、14）资产申购审批、15）资产入库、16）资产信息维护、17）资产借还、18）资产转移、19）资产维修、20）资产报废、21）资产报废审批、22）资产盘点、23）资产查询统计 2、Selenium设计方法选取范围 1）浏览器基本操作（如打开浏览器、输入地址、网页最大化等）、2）Selenium元素定位方法：id定位、3）Selenium元素定位方法：name定位、4）Selenium元素定位方法：xpath定位、5）Selenium元素定位方法：css_selector定位、6）Selenium元素定位方法：link_text定位、7）Selenium元素定位方法：partial_link_text定位、8）Selenium元素定位方法：class_name定位、9）Selenium元素定位方法：tag_name定位、10）Selenium复数元素定位方法、11）Selenium之鼠标模拟操作、12）Selenium之键盘模拟操作、13）Selenium之时间等待处理、14）Selenium之sumbit()方法使用、15）Selenium之页面中下拉框的处理、16）Selenium之操作下拉滚动条方法、17）Selenium之窗口切换、18）Selenium之页面元素属性删除、19）Selenium之文件上传处理、20）Selenium之页面截图操作、21）Selenium之alert弹出框处理、22）unittest自动化测试框架、23）读取csv文件、24）数据驱动、25）Page Object模式 性能测试1、性能测试功能点选取范围1）用户登录、2）用户退出、3）个人信息、4）部门管理、5）人员管理、6）资产类别、7）品牌、8）取得方式、9）供应商、10）存放地点、11）设备用途、12）报废方式、13）资产申购、14）资产申购审批、15）资产入库、16）资产信息维护、17）资产借还、18）资产转移、19）资产维修、20）资产报废、21）资产报废审批、22）资产盘点、23）资产查询统计 2、JMeter相关参数选取范围 线程组选取范围： 1）线程组、2）setUp线程组、3）tearDown线程组 取样器选取范围： 1）HTTP请求、2）调试取样器、3）FTP请求、4）Java请求 逻辑控制器选取范围： 1）事务控制器、2）循环控制器、3）交替控制器、4）仅一次控制器、5）随机控制器、6）随机顺序控制器、7）简单控制器 断言选取范围： 1）响应断言、2）JSON断言、3）大小断言 定时器选取范围： 1）固定定时器、2）统一随机定时器、3）高斯随机定时器、4）泊松随机定时器、5）同步定时器 配置元件选取范围： 1）CSV 数据文件设置、2）HTTP信息头管理器、3）HTTP Cookie管理器、4）HTTP缓存管理器、5）HTTP请求默认值、6）HTTP授权管理器、7）FTP默认请求、8）Java默认请求、9）随机变量 监听器选取范围： 1）察看结果树、2）汇总报告、3）聚合报告、4）汇总图、5）断言结果、6）图形结果、7）响应时间图 函数助手选取范围： 1）CSVRead、2）Random、3）RandomDate、4）RandomString、5）time JMeter运行选取范围：1）GUI运行、2）非GUI运行 在取样器错误后要执行的动作可设置： 继续，启动下一进程循环，停止线程，停止测试，立即停止测试。 场景配置虚拟用户数可设置： 1到100之间。 Ramp-Up****时间（秒）可设置： 1到60之间。 循环次数可设置： 永远，自定义次数。 调度器可设置： 启用，不启用。 调度器启用-持续时间可设置： 1min到30min之间。 调度器启用-启动延迟可设置： 无延迟，自定义时间。 测试结果数据截图取1到22单独图： 1）Test and Report information、2）APDEX (Application Performance Index)、3）Requests Summary、4）Statistics、5）Errors、6）Top 5 Errors by sampler、7） Response Times Over Time、8）Response Time Percentiles Over Time (successful responses)、9）Active Threads Over Time、10）Bytes Throughput Over Time、11）Latencies Over Time、12）Connect Time Over Time、13）Hits Per Second、14）Codes Per Second、15）Transactions Per Second、16）Total Transactions Per Second、17） Response Time Vs Request、18）Latency Vs Request、19）Response Time Percentiles、20）Response Time Overview、21）Time Vs Threads、22）Response Time Distribution 3、LoadRunner相关参数选取范围参数类型选取范围： 1）Date&#x2F;Time、2）File、3）Group Name、4）Iteration Number、5）Load Generator Name、6）Random Number、7）Table、Unique Number、8）User Defined Function、9）Vuser ID、10）XML 数据分配方法选取范围： 1）Sequential、2）Random、3）Unique 数据更新方式选取范围： 1）Each occurrence、2）Each iteration、3）Once 场景配置虚拟用户数可设置： 1到50之间。 持续时长可设置： 5min到20min之间，以及所有vuser运行完成。 递增虚拟用户数可设置： 1到20之间。 递增时长设置： 5s到30s之间。 递减虚拟用户数可设置： 1到20之间 ，以及运行完成结束。 递减时长可设置： 1s到60s之间，以及运行完成结束。 测试结果数据截图取1到23单独或组合图： 1）Summary Report、2）Running Vusers、3）Hit per Second、4）Throughput、5）Transaction Summary、6）Average Transaction Response Time、7）Vuser Summary、8）Rendezvous、9）Error Statistics (by Description)、10）Errors per Second (by Description)、11）Transactions per Second、12）Total Transactions per Second、13）Transaction Performance Summary、14）Transaction Response Time Under Load、15）Transaction Response Time (Percentile)、16）Transaction Response Time (Distribution)、17）Transaction Response Time By Location、18）Web Page Diagnostics、Page Component Breakdown、19）Page Download Time Breakdown、20）Time to First Buffer Breakdown、21）Downloaded Component Size (KB)、22）HTTP Status Code Summary、23）HTTP Responses per Second 接口测试1）PostMan Get接口请求、2)PostMan Post接口请求、3）PostMan环境变量、4）PostMan全局变量、5）PostMan测试断言、6）PostMan测试驱动、7）PostMan设置Cookie","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"软件测试考点","slug":"软件测试考点","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%80%83%E7%82%B9/"}]},{"title":"单元测试","slug":"软件测试/单元测试","date":"2022-10-20T12:02:34.000Z","updated":"2022-11-06T13:44:23.012Z","comments":true,"path":"2022/10/20/软件测试/单元测试/","link":"","permalink":"http://example.com/2022/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"assertThat - equalTo导包问题 解决方法equalTo comes from Hamcrest which is a JUnit dependency contained within the JUnit jar. You probably just need to import the static method for it from Hamcrest. 1import static org.hamcrest.core.IsEqual.*; 2022年10月21日 assertThat 需要导包 import static org.junit.Assert.*; eclipse如何一次性删除一行Ctrl + D 删除单行代码。 在eclipse中删除某一行就用ctrl+D快捷键 java8 API文档Java Development Kit 8 Documentation (oracle.com) JAVA String 用到的方法 字符串截取 image-20221021103053824 字符串转换 image-20221021103443881 image-20221021103601616 image-20221021103642773 image-20221021104533500 image-20221021110719174 字符串替换 image-20221021111317283 正则表达式–非非：首先，正则表达式的”非”，代表不想匹配某个字符。 比如字符串 helloword123，&#x2F;[^0-9]+&#x2F;g 可以匹配非数字，即匹配结果为 helloword； 同样的，&#x2F;[^he]+&#x2F;g 可以匹配非h非e的字符，匹配结果为lloword123； 非贪婪匹配？ 先行断言和后行断言编程胶囊-打造学习编程的最好系统 (codejiaonang.com) 开头的要写成 先行断言 先行断言 以前面的主体往后（主体要匹配完），可跟在^后 结尾的要写成 后行断言 后行断言 以后面的主体往前 （主体要匹配完），可跟在$前 java参数化和断言的使用 image-20221021144934339 image-20221021145006844 参数化 image-20221021155339403 Junit框架的使用（一）准备需测试类新建名称为Test的项目，在Test项目中新建一个Calculator.java，写入下面代码段，代码段中为加、减、乘、除运算。 代码段： 123456789101112131415161718192021public class Calculator &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void substract(int m, int n) &#123; result = m - n; &#125; public void multiply(int m, int n)&#123; result = m * n; &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; （二）在Eclipse项目中引入JUnit单元测试包JUnit是Java的一个框架，所以要求机器中已经安装好JDK并且配置好了Java运行环境。 1、在该项目上点右键，选择“Bulid Path”—-&gt;“Add Libraries…”。 img 2、弹出“Add Library”窗口，选择“JUnit”，点“Next”。选择JUnit4，点“Finish”，JUnit测试包导入成功。 IMG_256 （三）生成JUnit测试框架1、在Eclipse的Package Explorer中用右键点击Calculator.java类弹出菜单，选择“New”—-&gt;“JUnit Test Case”。如下图所示： img 2、在弹出的对话框中，进行相应的选择，如下图所示： IMG_256 3、点击“Next”后，系统会自动列出Calculator这个类中包含的方法，选择要进行测试的方法。在该例中我们需要对“加、减、乘、除”四个方法进行测试，勾选相应的方法。如下图所示： IMG_256 4、系统会自动生成一个新类CalculatorTest，里面包含一些空的测试用例。如下图所示： img （四）编写测试类编写测试用例类。完整的CalculatorTest代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142import static org.junit.Assert.*;import org.junit.After;import org.junit.Before;import org.junit.Test; public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @Before public void setUp() throws Exception &#123; calculator.clear(); &#125; @After public void tearDown() throws Exception &#123; &#125; @Test public void testAdd() &#123; calculator.add(3, 4); //assertEquals判断对象中的值是否是期待的值7 assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125; @Test public void testMultiply() &#123; calculator.multiply(5,5); assertEquals(25, calculator.getResult()); &#125; @Test public void testDivide() &#123; calculator.divide(8,4); assertEquals(2, calculator.getResult()); &#125;&#125; （五）运行测试代码1、按照上述代码修改完毕后，我们在CalculatorTest类上点右键，选择“Run As”—–&gt;“JUnit Test”来运行我们的测试，如下图所示： img 2、运行结果如下： 具体的测试结果在进度条上面有表示“共进行了4个测试”，4个均测试通过。 img JUnit常用注释实训指导书任务准备背景知识JUnit之前对测试类测试方法命名限制比较多，到了 JUnit4 引入了注解，在 JUnit4 中对类名称和方法名称不再限制，可以根据各人的编程习惯命名，只需要加上对应的注解，导入相应的包就可以了。Java注解（(Annotation）的使用方法是@注解名，能通过简单的词语来实现一些功能。在测试过程中测试执行所需要的固定环境称为Test Fixture，Fixtures主要目的是建议一个固定&#x2F;已知的环境状态确保测试可重复并且按照预期结果来运行。JUnit提供有两个类级别（@BeforeClass、@AfterClass），两个方法级别（@Before、@After）的fixture注释。 在JUnit4 中常用的注解有@Test、@BeforeClass、@AfterClass、@Before、@After。 方法注解：@BeforeClass：它会在所有的测试方法执行之前被执行，只执行一次该方法，且必须为 public static void。当运行一些关联的用例时，可能会需要执行一些相同的操作，这时可将共用的部分提取出来，放在一个方法里，并且这个方法注解为@BeforeClass。意思是在测试类里所有用例运行之前，运行一次这个方法。例如创建数据库连接、读取文件等。 @AfterClass：同@BeforeClass对应，在所有的测试方法执行完成后被执行，只执行一次该方法，且必须为 public static void。例如关闭数据量连接、释放 IO 连接资源，恢复现场等。 @Before：与@BeforeClass的区别在于，@Before不止运行一次，会在每一个测试方法被运行前执行一次，运行次数根据用例数而定，且必须为 public void。常用于一些独立于用例之间的准备工作，如进行测试环境或数据的准备。例如两个用例都需要读取数据库里的相同一条数据，但第一个用例会删除这条数据，而第二个用例需要编辑这条数据。就可以用 @BeforeClass来创建数据库连接。用@Before来执行插入这条数据。也可以用 @Before 来注释多个方法，这些方法都在每个测试之前运行。 @After：同@Before对应，会在每一个测试方法被运行结束后执行一次，且必须为 public void。常用与进行一些数据清理工作。 @Test：将一个普通的方法修饰成为一个测试方法，在方法前添加@Test注释，就把这个方法标记为一个单元测试方法。测试方法必须为 public void。方法名字可以随便取，没有任何限制，但是规范写法是test+方法名，方法名第一个子母大写。方法不能有任何参数。 @Ignore：该注解标记的测试方法会被忽略，所修饰的测试方法不会被运行器执行。比如当测试的方法还没有实现，或者测试的方法已经过时。忽略或者禁止junit测试类上的所有方法的执行，则在测试类上添加@Ignore注解即可。@Ignore(&quot;message&quot;)，message可以备注为什么忽略。 一个JUnit 4 的单元测试用例执行顺序为： @BeforeClass–&gt; （@Before –&gt; @Test –&gt; @After ）–&gt;（@Before –&gt; @Test –&gt; @After ）–&gt; @AfterClass 每一个测试方法的调用顺序为：@Before –&gt; @Test –&gt; @After 需测试类代码段：需测试类Calculator代码如下：123456789101112131415161718192021public class Calculator &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void substract(int m, int n) &#123; result = m - n; &#125; public void multiply(int m, int n)&#123; result = m * n; &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; 代码段：测试用例类CalculatorTest代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import static org.junit.Assert.*;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Ignore;import org.junit.Test; public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @BeforeClass public static void setUpBeforeClass() throws Exception &#123; System.out.println(&quot;beforeClass&quot;); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; System.out.println(&quot;AfterClass&quot;); &#125; @Before public void setUp() throws Exception &#123; calculator.clear(); System.out.println(&quot;before&quot;); &#125; @After public void tearDown() throws Exception &#123; System.out.println(&quot;After&quot;); &#125; @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); System.out.println(&quot;testAdd&quot;); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); System.out.println(&quot;testSubstract&quot;); &#125; @Ignore @Test public void testMultiply() &#123; System.out.println(&quot;testMultiply&quot;); &#125; @Test public void testDivide() &#123; calculator.divide(8,4); assertEquals(2, calculator.getResult()); System.out.println(&quot;testDivide&quot;); &#125;&#125; 执行结果：执行结果显示有3个测试通过，1个测试忽略。 img 打印结果可看出@BeforeClass和@AfterClass只执行了一次，@Before和@After每个测试方法被运行就执行一次，@Ignore注释的testMultiply方法被忽略未执行。 1234567891011beforeClassbeforetestAddAfterbeforetestSubstractAfterbeforetestDivideAfterAfterClass 实训3 JUnit断言方法-assert背景知识编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设。断言主要使用在代码开发和测试时期，用于对某些关键数据的判断，如果这个关键数据不是你程序所预期的数据，程序就提出警告或退出。 使用断言可以创建更稳定、品质更好且不易于出错的代码。当需要在一个值为FALSE时中断当前操作的话，可以使用断言。单元测试必须使用断言。 Junit 4断言方法允许检查测试方法的期望结果值和真实返回值，来帮助我们确定被测试的方法是否按照预期的效果正常工作。Junit的org.junit.Assert类提供了各种断言方法来。下面我们来介绍一下JUnit的各种断言。 assert断言方法断言方法参数统一说明：message是个可选的消息，假如提供，将会在发生错误时报告这个消息。expected是期望值，通常都是用户指定的内容。 actual是被测试的代码返回的实际值。 assertArrayEquals(“message”,expecteds, actuals) 该断言用来比较两个数组是否相等。 assertEquals(“message”,expecteds,actuals) 该断言用来比较两个对象是否相等。与字符串比较中使用的equals()方法类似。 assertSame(“message”,expecteds,actuals) 该断言用来比较两个对象的引用是否相等。之前的assert方法是检查A与B是否有相同的值（使用了equals方法），而assertSame方法则是检查A与B就是同一个对象（使用的是&#x3D;&#x3D;操作符）。 assertNotSame(“message”,expecteds,actuals) 该断言用来比较两个对象的引用是否相等和不相等，类似于通过“!&#x3D;”比较两个对象。 assertTrue(“message”,condition) 该断言用来验证条件是否为真，查看的变量的值是true则测试成功，如果是false则失败。 assertFalse(“message”,condition) 该断言用来验证条件是否为假，查看的变量的值是false则测试成功，如果是true则失败。 assertNull(“message”,object) 该断言用来验证给定的对象是否为null，假如不为null，则验证失败。 assertNotNull(“message”,object) 该断言用来验证给定的对象是否为不为null，假如为null，则验证失败。 （一）代码段：JUnit断言使用方法演示代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import static org.junit.Assert.*; import org.junit.Test;public class AssertionsTest &#123; @Test public void testAssertArrayEquals() &#123; int[] expected = &#123;3&#125;; int[] actual = &#123;3&#125;; assertArrayEquals(&quot;failure - not same&quot;, expected, actual); &#125; @Test public void testAssertEquals() &#123; long long1 = 50; long long2 = 50; assertEquals(&quot;failure - not same&quot;, long1, long2); &#125; @Test public void testAssertSame() &#123; String str1 = &quot;hello world!!&quot;; String str2 = &quot;hello world!!&quot;; assertSame(&quot;failure - not same&quot;,str2, str1); &#125; @Test public void testAssertNotSame() &#123; String str1 = &quot;hello world!!&quot;; String str2 = &quot;hello java!!&quot;; assertNotSame(&quot;failure - same&quot;,str1, str2); &#125; @Test public void testAssertTrue() &#123; assertTrue(&quot;failure - false&quot;,1==1); &#125; @Test public void testAssertFalse() &#123; assertFalse(&quot;failure - true&quot;,1==2); &#125; @Test public void testAssertNull() &#123; String str = null; assertNull(&quot;failure - not null&quot;,str); &#125; @Test public void testAssertNotNull() &#123; String str = &quot;hello Java!!&quot;; assertNotNull(&quot;failure - null&quot;,str); &#125; &#125; （二）执行结果：执行结果显示有8个测试通过。 img 任务步骤按照上面讲解的JUnit断言的知识，给下面的代码段设计测试类，写出测试方法并执行测试。 要求如下： 1、用户信息为：名称“Fred”、年龄“18”、性别“男”、电话号码“13612251254”、其他属性为null、身高体重{170,65}； 2、使用assertSame判断用户名称为“Fred”； 3、使用assertNotSame判断用户名称不为“Hero”； 4、使用assertEquals判断年龄为18岁； 5、使用assertTrue验证性别为男； 6、使用assertFalse验证性别不为女； 7、使用assertNull验证其他属性为null； 8、使用assertNotNull验证电话号码不为空； 9、使用assertArrayEquals验证身高和体重为170，65。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Person &#123; String name;//姓名 int age;//年龄 String sex;//身高 String no;//电话号码 int[] heigwei;//身高体重 String code;//其他属性 public Person(String namec, int agec, String sexc, String noc, String codec, int... heigweic) &#123; name = namec; age= agec; sex = sexc; no = noc; code = codec; heigwei = heigweic; &#125; //获取名称 public String getName() &#123; return name; &#125; //获取年龄 public int getAge() &#123; return age; &#125; //获取性别 public int getSex() &#123; if(sex==&quot;男&quot;) &#123; return 1; &#125;else &#123; return 0; &#125; &#125; //获取其他属性 public String getCode()&#123; return code; &#125; //获取电话号码 public String getNo()&#123; return no; &#125; //获取身高体重 public int[] getHeigwei() &#123; return heigwei; &#125; &#125; 任务总结通过本次实训，完成JUnit的assert断言方法学习，为进行白盒测试奠定基础。实训难度一般，知识点主要在于JUnit的assert各种断言方法的理解和练习，要求学生熟练掌握assert断言方法的知识点。 JUnit断言assertThat-一般匹配符背景知识JUnit4结合Hamcrest提供了一个全新的断言语法–assertThat。程序员使用assertThat的一个断言语句并且结合Hamcrest提供的匹配符，就可以表达出全部的测试思想，这些匹配符更接近自然语言，可读性高，更加灵活。 assertThat的优点如下： 1、使用一条assertThat可以替代所有的实训3中的所有断言语句，这样可以在所有的单元测试中只是用一种断言方法，使得编写测试用例变得简单，代码风格统一，测试代码也更易维护。 2、assertThat使用了Hamcrest的Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活，可以达到更多的目的。 3、assertEquals使用的是比较难懂的“谓宾主”语法模式，期望值在前，实际值在后 （如：assertEquals(expecteds,actuals);）不易于理解和记忆；assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(actuals,is(expecteds));），使得代码更加直观、易读。 4、assertThat错误信息更加易懂、可读且具有描述性，assertEquals 默认出错后不会抛出额外提示信息，错误信息不明确。 一般匹配符： allOf 匹配符表明如果接下来的所有条件必须都成立测试才通过，相当于“与”（&amp;&amp;）； assertThat( testedNumber, allOf( greaterThan(4), lessThan(10) ) );。 anyOf 匹配符表明如果接下来的所有条件只要有一个成立则测试通过，相当于“或”（||）；assertThat( testedNumber, anyOf( greaterThan(10), lessThan(4) ) );。 anything 匹配符表明无论什么条件，永远为true； assertThat( testedNumber, anything() );。 is 匹配符表明如果前面待测的object等于后面给出的object，则测试通过； assertThat( testedString, is( &quot;developerWorks&quot; ) );。 not 匹配符和is匹配符正好相反，表明如果前面待测的object不等于后面给出的object，则测试通过； assertThat( testedString, not( &quot;developerWorks&quot; ) );。 步骤：（一）下载Hamcrest包1、下载hamcrest-library.jar、hamcrest-core.jar包。 （二）在Eclipse项目中引入Hamcrest包1、项目上点右键，选择“Bulid Path”—-&gt;“Add External Archives…”。 img 2、选择下载的hamcrest-library.jar、hamcrest-core.jar包，引入成功。在测试的class中导入后就可以使用assertThat方法了。 12import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*; （三）被测代码段：123456789101112 public class AssertThat &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; （四）测试类代码段：123456789101112131415161718192021222324252627import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import org.junit.Before;import org.junit.Test;public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Before public void setUp() throws Exception&#123; ass.clear(); &#125; @Test public void testAdd() &#123; ass.add(3, 4); //allOf：所有条件必须都成立，测试才通过 ，结果在6和8之间 assertThat(ass.getResult(), allOf(greaterThan(6), lessThan(8))); //anyOf只要有一个条件成立，测试就通过 assertThat(ass.getResult(), anyOf(greaterThan(6), lessThan(5))); //anyOf只要有一个条件成立，测试就通过 assertThat(ass.getResult(), anyOf(greaterThan(8), lessThan(9))); //anything：无论什么条件，测试都通过 assertThat(ass.getResult(), anything()); //is：变量的值等于指定值时，测试通过 assertThat(ass.getResult(), is(7)); //not：和is相反，变量的值不等于指定值时，测试通过 assertThat(ass.getResult(), not(2)); &#125;&#125; （五）执行结果：执行结果显示测试通过。 img 任务步骤按照上面讲解的JUnit新的断言assertThat中一般匹配符的知识，给下面的代码段设计测试类，写出测试方法并执行测试，使用assertThat中的allof、anyof、anthing、is、not来进行判断。 要求如下： 1、减法方法计算10-7，判断计算的值在2和4之间； 2、减法方法计算10-7，判断计算的值大于2或者小于1； 3、减法方法计算10-7，判断计算的值大于4或者小于7； 4、减法方法计算10-7，判断无论什么条件都测试通过； 5、减法方法计算10-7，判断是否等于3； 6、减法方法计算10-7，判断不等于2； 7、除法方法计算8&#x2F;4，判断计算的值在1和3之间； 8、除法方法计算8&#x2F;4，判断计算的值大于1或者小于1； 9、除法方法计算8&#x2F;4，判断计算的值大于8或者小于3； 10、除法方法计算8&#x2F;4，判断无论什么条件都测试通过； 11、除法方法计算8&#x2F;4，判断是否等于2； 12、除法方法计算8&#x2F;4，判断不等于1。 123456789101112131415public class AssertThat2 &#123; private static int result; public void substract(int m, int n) &#123; result = m - n; &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; 任务总结通过本次实训，完成JUnitJUnit新的断言assertThat中的allof、anyof、anthing、is、not学习，为进行白盒测试奠定基础。实训难度一般，知识点主要在于assertThat中的一般匹配符断言方法的理解和练习，要求学生熟练掌握JUnit新的断言assertThat方法的知识点。 JUnit断言assertThat-字符串相关匹配符背景知识JUnit4结合Hamcrest提供了一个全新的断言语法–assertThat。程序员使用assertThat的一个断言语句并且结合Hamcrest提供的匹配符，就可以表达出全部的测试思想，这些匹配符更接近自然语言，可读性高，更加灵活。 assertThat的优点如下： 1、使用一条assertThat可以替代所有的实训3中的所有断言语句，这样可以在所有的单元测试中只是用一种断言方法，使得编写测试用例变得简单，代码风格统一，测试代码也更易维护。 2、assertThat使用了Hamcrest的Matcher 匹配符，用户可以使用匹配符规定的匹配准则精确的指定一些想设定满足的条件，具有很强的易读性，而且使用起来更加灵活，可以达到更多的目的。 3、assertEquals使用的是比较难懂的“谓宾主”语法模式，期望值在前，实际值在后 （如：assertEquals(expecteds,actuals);）不易于理解和记忆；assertThat 使用了类似于“主谓宾”的易读语法模式（如：assertThat(actuals,is(expecteds));），使得代码更加直观、易读。 4、assertThat错误信息更加易懂、可读且具有描述性，assertEquals 默认出错后不会抛出额外提示信息，错误信息不明确。 字符串相关匹配符： containsString assertThat( testedString, containsString( &quot;developerWorks&quot; ) ); 匹配符表明如果测试的字符串testedString 包含子字符串”developerWorks“则测试通过。 endsWith assertThat( testedString, endsWith( &quot;developerWorks&quot; ) ); 匹配符表明如果测试的字符串testedString以子字符串”developerWorks“结尾则测试通过。 startsWith assertThat( testedString, startsWith( &quot;developerWorks&quot; ) ); 匹配符表明如果测试的字符串testedString以子字符串”developerWorks“开始则测试通过。 equalTo assertThat( testedValue, equalTo( expectedValue ) ); 匹配符表明如果测试的testedValue等于expectedValue则测试通过，equalTo可以测试数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法。 equalToIgnoringCase assertThat( testedString, equalToIgnoringCase( &quot;developerWorks&quot; ) ); 匹配符表明如果测试的字符串testedString在忽略大小写的情况下等于”developerWorks“则测试通过。 equalToIgnoringWhiteSpace assertThat( testedString, equalToIgnoringWhiteSpace( &quot;developerWorks&quot; ) ); 匹配符表明如果测试的字符串testedString在忽略头尾的任意个空格的情况下等于”developerWorks“则测试通过，注意：字符串中的空格不能被忽略。 步骤：（一）被测代码段：123456789101112131415 public class AssertThat &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125; public String getName(String name) &#123; return name; &#125; &#125; （二）测试类代码段：1234567891011121314151617181920212223242526272829303132import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import org.junit.Before;import org.junit.Test;public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Before public void setUp() throws Exception&#123; ass.clear(); &#125; @Test public void testAdd() &#123; ass.add(3, 4); //euqalTo：相加结果为7，测试通过 assertThat(ass.getResult(), equalTo(7)); &#125; @Test public void testGetName() &#123; //containsString：字符串变量中包含指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), containsString(&quot;ni&quot;)); //startsWith：字符串变量以指定字符串开头时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), startsWith(&quot;Mo&quot;)); //endsWith：字符串变量以指定字符串结尾时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), endsWith(&quot;ka&quot;)); //euqalTo：字符串变量等于指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), equalTo(&quot;Monika&quot;)); //equalToIgnoringCase：忽略大小写的情况下等于指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), equalToIgnoringCase(&quot;monikA&quot;)); //equalToIgnoringWhiteSpace：忽略头尾任意空格的情况下等于指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), equalToIgnoringWhiteSpace(&quot; Monika &quot;)); &#125;&#125; （三）执行结果：执行结果显示测试通过。 img 任务步骤按照上面讲解的JUnit新的断言assertThat的知识，给下面的代码段设计测试类，写出测试方法并执行测试，使用assertThat中的containsString、endsWith、startsWith、equalTo、equalToIgnoringCase、equalToIgnoringWhiteSpace来进行判断。 要求如下： 1、信息为：名称“Tomcat”、年龄“5”； 2、判断名称中是否包含“om”； 3、判断名称是否以“To”开头； 4、判断名称是否以“at”结束； 5、判断名称是否是“Tomcat”； 6、判断名称忽略大小写是否同“tomCat”一致； 7、判断名称忽略头尾空格是否同“ Tomcat ”一致； 8、判断年龄是否是“5”。 12345678910111213141516public class Pet &#123; private static String name; private static int age; public Pet(String namep,int agep) &#123; name = namep; age = agep; &#125; //获取名称 public String getName() &#123; return name; &#125; //获取年龄 public int getAge() &#123; return age; &#125;&#125; 任务总结通过本次实训，完成JUnitJUnit新的断言assertThat中的containsString、endsWith、startsWith、equalTo、equalToIgnoringCase、equalToIgnoringWhiteSpace学习，为进行白盒测试奠定基础。实训难度一般，知识点主要在于assertThat中的字符串相关匹配符断言方法的理解和练习，要求学生熟练掌握JUnit新的断言assertThat方法的知识点。 JUnit断言assertThat-数值相关匹配符数值相关匹配符 closeTo assertThat( testedDouble, closeTo( 10.0, 0.5 ) ); 匹配符表明如果所测试的浮点型数testedDouble在10.0±0.5范围之内则测试通过。 greaterThan assertThat( testedNumber, greaterThan(10.0) ); 匹配符表明如果所测试的数值testedNumber大于10.0则测试通过。 lessThan assertThat( testedNumber, lessThan (8.0) ); 匹配符表明如果所测试的数值testedNumber小于8.0则测试通过。 greaterThanOrEqualTo assertThat( testedNumber, greaterThanOrEqualTo (10.0) ); 匹配符表明如果所测试的数值testedNumber大于等于10.0则测试通过。 lessThanOrEqualTo assertThat( testedNumber, lessThanOrEqualTo (10.0) ); 匹配符表明如果所测试的数值testedNumber小于等于10.0则测试通过。 步骤：（一）被测代码段：12345678910111213public class AssertThat &#123; private static double result; public void div(double a, double b) &#123; result = a / b; &#125; public void clear() &#123; result = 0; &#125; public double getResult() &#123; return result; &#125;&#125; （二）测试类代码段：1234567891011121314151617181920212223242526import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import org.junit.Before;import org.junit.Test;public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Before public void setUp() throws Exception &#123; ass.clear(); &#125; @Test public void testDiv() &#123; ass.div(20, 3); //closeTo：计算结果值在6.0±0.8范围内，测试通过 assertThat(ass.getResult(), closeTo(6.0, 0.8)); //greaterThan：计算结果值大于6时，测试通过 assertThat(ass.getResult(), greaterThan(6.0)); //lessThan：计算结果值小于8时，测试通过 assertThat(ass.getResult(), lessThan(8.0)); //greaterThanOrEuqalTo：计算结果值大于等于6.6时，测试通过 assertThat(ass.getResult(), greaterThanOrEqualTo(6.6)); //lessThanOrEqualTo：计算结果值小于等于6.7时，测试通过 assertThat(ass.getResult(), lessThanOrEqualTo(6.7)); &#125;&#125; （三）执行结果：执行结果显示测试通过。 img 任务步骤按照上面讲解的JUnit新的断言assertThat的知识，给下面的代码段设计测试类，写出测试方法并执行测试，使用assertThat中的closeTo、greaterThan、lessThan、greaterThanOrEqualTo、lessThanOrEqualTo来进行判断。 要求如下： 1、减法方法计算8.8-7.5，判断计算的值大于1或者小于2； 2、减法方法计算8.8-7.5，判断计算的值大于等于1或者小于等于1.5； 3、减法方法计算8.8-7.5；判断计算的值在1±0.5范围内并且也在2±0.8范围内； 123456789101112 public class AssertThat &#123; private static double result; public void substract(double m, double n) &#123; result = m - n; &#125; public void clear() &#123; result = 0; &#125; public double getResultOne() &#123; return result; &#125; &#125; 任务总结通过本次实训，完成JUnitJUnit新的断言assertThat中的closeTo、greaterThan、lessThan、greaterThanOrEqualTo、lessThanOrEqualTo学习，为进行白盒测试奠定基础。实训难度一般，知识点主要在于assertThat中的数值相关匹配符断言方法的理解和练习，要求学生熟练掌握JUnit新的断言assertThat方法的知识点。 JUnit断言assertThat-集合相关匹配符集合相关匹配符 hasItemInArray assertThat( Array, hasItemInArray( &quot;element&quot; ) ); 匹配符表明如果测试的数组Array含有元素“element”项则测试通过。 hasItem assertThat( iterableObject, hasItem ( &quot;element&quot; ) ); 匹配符表明如果测试的迭代对象iterableObject含有元素“element”项则测试通过。 hasItems assertThat(iterableObject, hasItems(&quot;element1&quot;, &quot;element2&quot;)); 匹配符表明如果测试的迭代对象iterableObject中至少含有元素“element1”、“element2”则测试通过。 containsInAnyOrder assertThat(iterableObject,containsInAnyOrder(&quot;element1&quot;,&quot;element2&quot;,&quot;element3&quot;)); 匹配符表明如果测试的迭代对象iterableObject只含有元素为“element1”、“element2”和“element3”项则测试通过。 hasEntry assertThat( mapObject, hasEntry( &quot;key&quot;, &quot;value&quot; ) ); 匹配符表明如果测试的Map对象mapObject含有一个键值为”key“对应元素值为”value“的Entry项则测试通过。 hasKey assertThat( mapObject, hasKey ( &quot;key&quot; ) ); 匹配符表明如果测试的Map对象mapObject含有键值“key”则测试通过。 hasValue assertThat( mapObject, hasValue ( &quot;value&quot; ) ); 匹配符表明如果测试的Map对象mapObject含有元素值“value”则测试通过。 步骤：（一）被测代码段：12345678910111213141516171819202122import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map; public class AssertThat &#123;public String[] getString(String a,String b,String c) &#123; String[] s = &#123;a,b,c&#125;; return s; &#125; public List&lt;String&gt; getList(String al,String bl,String cl) &#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(al); l.add(bl); l.add(cl); return l; &#125; public Map&lt;String, String&gt; getMap(String key, String value) &#123; Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;(); m.put(key, value); return m; &#125; &#125; （二）测试类代码段：12345678910111213141516171819202122232425262728293031323334353637import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import java.util.List;import java.util.Map;import org.junit.Test;public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Test public void testGetString() &#123; String[] s = ass.getString(&quot;ABC&quot;, &quot;DEF&quot;, &quot;GHI&quot;); // hasItemInArray：测试一个数组包含一个元素 assertThat(s, hasItemInArray(startsWith(&quot;DE&quot;))); &#125; @Test public void testGetList() &#123; List&lt;String&gt; l = ass.getList(&quot;Magci&quot;, &quot;Fred&quot;, &quot;Hero&quot;); // hasItem：Iterable变量中含有指定元素时，测试通过 assertThat(l, hasItem(startsWith(&quot;F&quot;))); // 检查多个元素是否在集合中 assertThat(l, hasItems(&quot;Fred&quot;, &quot;Magci&quot;)); // 检查集合中元素是否同多个元素一致 assertThat(l, containsInAnyOrder(&quot;Fred&quot;, &quot;Hero&quot;, &quot;Magci&quot;)); &#125; @Test public void testGetMap() &#123; Map&lt;String, String&gt; m = ass.getMap(&quot;name&quot;, &quot;Fred&quot;); // hasEntry：Map变量中含有指定键值对时，测试通过 assertThat(m, hasEntry(&quot;name&quot;, &quot;Fred&quot;)); // hasKey：Map变量中含有指定键时，测试通过 assertThat(m, hasKey(&quot;name&quot;)); // hasValue：Map变量中含有指定值时，测试通过 assertThat(m, hasValue(&quot;Fred&quot;)); &#125;&#125; （三）执行结果：执行结果显示测试通过。 img 任务步骤按照上面讲解的JUnit新的断言assertThat的知识，给下面的代码段设计测试类，写出测试方法并执行测试，使用assertThat中的hasItemInArray、hasItem、hasItems、containsInAnyOrder、hasEntry、hasKey、hasValue来进行判断。 要求如下： 1、方法一传入数据(“ABC”, “DEF”, “GHI”)，判断数组中是否包含以“DE”开头的元素； 2、方法二传入数据(“Magci”, “Fred”, “Hero”,”Alice”)，判断集合中是否有“e”结尾的元素； 3、方法二传入数据(“Magci”, “Fred”, “Hero”,”Alice”)，判断”Magci”, “Fred”在集合中并且”Tom”, “Cat”不在集合中； 4、方法二传入数据(“Magci”, “Fred”, “Hero”,”Alice”)，判断集合中是否只包含”Magci”, “Fred”, “Hero”,”Alice”四个元素或者只包含”Fred”, “Hero”两个元素； 5、方法三传入数据(“name”, “Fred”,”age”,”18”)，判断集合中键值对”name”, “Fred”或者键值对”age”,”18”； 6、方法三传入数据(“name”, “Fred”,”age”,”18”)，判断集合中不包含键值”weight”； 7、方法三传入数据(“name”, “Fred”,”age”,”18”)，判断集合中包含忽略大小写的元素值”fred”。 123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class AssertThat &#123; //方法一 public String[] getString(String a,String b,String c) &#123; String[] s = &#123;a,b,c&#125;; return s; &#125; //方法二 public List&lt;String&gt; getList(String al,String bl,String cl,String d1) &#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(al); l.add(bl); l.add(cl); l.add(d1); return l; &#125; //方法三 public Map&lt;String, String&gt; getMap(String keyo, String valueo,String keyt, String valuet) &#123; Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;(); m.put(keyo, valueo); m.put(keyt, valuet); return m; &#125;&#125; 任务总结通过本次实训，完成JUnitJUnit新的断言assertThat中的hasItemInArray、hasItem、hasItems、containsInAnyOrder、hasEntry、hasKey、hasValue学习，为进行白盒测试奠定基础。实训难度一般，知识点主要在于assertThat中的集合相关匹配符断言方法的理解和练习，要求学生熟练掌握JUnit新的断言assertThat方法的知识点。 JUnit限时和异常测试背景知识在实际测试中，测试一些逻辑复杂、循环嵌套较深的程序，很可能会出现死循环，进入死循环就无法自动终止。因此在测试中需要采取一些预防措施，@Test注解提供1个参数“timeout”可以使用在该场景。使用“timeout”就是给测试函数设定一个执行时间，如果测试运行时间长于定义的时间，执行方法会被系统强行终止，测试失败。并且系统还会汇报该测试方法是因为超时才结束。@Test(timeout = 1000)表示如1000ms未执行完成，就因为超时而自动终止。 在开发过程中，JAVA中的异常处理也是重点，异常的捕获、抛出和异常处理是维持代码健壮性的重要条件，灵活使用异常以及处理异常，不仅能最大限度的避免出错而且也能增加软件的容错能力。在进行单元测试时，我们除了需要测试正常流程和正确的程序功能置外，可能还需要测试异常场景。如果一个函数应该抛出异常但是却没有抛出异常这说明程序有Bug。在JUnit中@Test注解提供一个参数测试异常情况，@Test(expected…)定义测试方法应该抛出的异常类型，如果方法调用中抛出了这个异常则测试通过，如果测试方法没有抛出异常或者抛出了一个不同的异常，测试失败。 步骤：（一）被测代码段：12345678910111213public class TimeException &#123; private static int result; //无限while循环 public void time()&#123; while(true); &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public int getResult() &#123; return result; &#125;&#125; （二）测试类代码段：超时设置timeout&#x3D;1000，1000毫秒未执行完成显示测试失败； 12345678910111213除法输入数据计算后如为ArithmeticException类异常，测试成功。（ArithmeticException为&quot;数学运算异常&quot;）import org.junit.Test;public class TimeExceptionTest &#123; private static TimeException timeexception = new TimeException(); @Test(timeout=1000) public void testTime() &#123; timeexception.time(); &#125; @Test(expected = ArithmeticException.class) public void testDivide() &#123; timeexception.divide(10, 0); &#125;&#125; （三）执行结果：testTime执行失败。testDivide执行成功 img 任务步骤按照上面的JUnit限时和异常测试知识讲解，根据下面的代码段按照要求来设计测试类。 要求如下： 1、sum测试方法设置超时时间为500毫秒； 2、array测试方法传入数组下标越界，判断数组下标越界异常。 12345678910111213public class TimeException &#123; private static String result; public void sum()&#123; for(;;); &#125; public void array(int m) &#123; String[] array = &#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;gkl&quot;&#125;; result = array[m]; &#125; public String getResult() &#123; return result; &#125;&#125; 任务总结通过本次实训，完成JUnit限时和异常测试的使用，为进行白盒测试奠定基础。实训难度较低，知识点主要在于了解限时和异常测试的使用场景和使用方法，要求学生熟练掌握JUnit限时和异常测试的知识点。 JUnit参数化设置背景知识在测试过程中，我们可能会遇到这样的函数，它的参数有许多特殊值，我们需要把这些特殊值都要进行测试。比如测试“登录”函数，测试中比如需要测试用户名密码正确、用户名不正确、密码不正确。在编写测试类的时候，至少要写3个测试方法，才能把这3种情况都包含，测试代码如下： 被测代码段： 123456789public class Register &#123; public boolean LogOn(String username, String password) &#123; if (username == &quot;Admin&quot; &amp;&amp; password == &quot;123456&quot;) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 测试代码段：12345678910111213141516171819import static org.junit.Assert.*;import org.junit.Test; public class RegisterTest &#123; private Register register = new Register(); @Test public void testLogOn() &#123; assertEquals(true,register.LogOn(&quot;Admin&quot;, &quot;123456&quot;)); &#125; @Test public void testLogOn1() &#123; assertEquals(false,register.LogOn(&quot;student&quot;, &quot;123456&quot;)); &#125; @Test public void testLogOn2() &#123; assertEquals(false,register.LogOn(&quot;Admin&quot;, &quot;123&quot;)); &#125;&#125; 通过上面的例子，我们发现编写多个测试方法进行各类数据测试时，除了传入参数不同，其他代码都相同，写了大量重复的代码。为了简化类似的测试，JUnit4提出了“参数化测试”的概念，就是只写一个测试函数，把多种情况作为参数传递进去，使用不同的值反复运行同一个测试，就可以避免写大量重复的代码。下面介绍参数化测试的流程 （一）采用参数化测试的步骤：1、为测试类指定特殊运行器，用@RunWith(Parameterized.class)来注释测试类。 123456import org.junit.runner.RunWith;import org.junit.runners.Parameterized;@RunWith(Parameterized.class)public class RegisterTest&#123; ...............&#125; 2、在测试类中，声明变量，用来保存测试数据，也可保存期望值。 12345678910import org.junit.runner.RunWith;import org.junit.runners.Parameterized; @RunWith(Parameterized.class)public class RegisterTest &#123; private String username; private String password; private boolean expected; ......&#125; 3、创建一个由@Parameters注释的公共静态方法，返回类型为Collection，初始化需要测试的数据。 1234567891011121314151617181920212223import java.util.Arrays;import java.util.Collection;import org.junit.runner.RunWith;import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class)public class RegisterTest &#123;private Register register = new Register();private String username; private String password; private boolean expected; //测试数据集合，方法名可以随意定义，返回类型可变，但是必须用@Parameters标注 @Parameters public static Collection userData() &#123; // 数组中，包含了传入参数和期望结果，数组参数顺序与构造函数参数顺序一致即可 return Arrays.asList(new Object[][]&#123; &#123;&quot;Admin&quot;,&quot;123456&quot;,true&#125;, &#123;&quot;student&quot;,&quot;123456&quot;,false&#125;, &#123;&quot;Admin&quot;,&quot;123&quot;,false&#125;&#125;); ...... &#125;&#125; 4、声明一个公共的构造函数，构造函数的参数为第2步的变量。构造函数参数的赋值顺序，同第3步中初始化数据对的参数顺序一致。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Collection;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class)public class RegisterTest &#123;private Register register = new Register();private String username;private String password;private boolean expected; //测试数据集合，方法名可以随意定义，返回类型可变，但是必须用@Parameters标注 @Parameterspublic static Collection userData() &#123;// 数组中,包含了传入参数和期望结果，数组参数顺序与构造函数参数顺序一致即可 return Arrays.asList(new Object[][]&#123; &#123;&quot;Admin&quot;,&quot;123456&quot;,true&#125;, &#123;&quot;student&quot;,&quot;123456&quot;,false&#125;, &#123;&quot;Admin&quot;,&quot;123&quot;,false&#125;&#125;); &#125; //构造函数，参数赋值顺序与测试数据集合一致 public RegisterTest(String username,String password,boolean expected) &#123; this.username = username; this.password = password; this.expected = expected; &#125; ......&#125; 5、编写测试代码，用初始化的参数进行测试。 1234567891011121314151617181920212223242526272829303132333435import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class)public class RegisterTest &#123; private Register register = new Register(); private String username; private String password; private boolean expected; //测试数据集合，方法名可以随意定义，返回类型可变，但是必须用@Parameters标注 @Parameters public static Collection userData() &#123; // 数组中,包含了传入参数和期望结果，数组参数顺序与构造函数参数顺序一致即可 return Arrays.asList(new Object[][]&#123; &#123;&quot;Admin&quot;,&quot;123456&quot;,true&#125;, &#123;&quot;student&quot;,&quot;123456&quot;,false&#125;, &#123;&quot;Admin&quot;,&quot;123&quot;,false&#125;&#125;); &#125; //构造函数，参数赋值顺序与测试数据集合一致 public RegisterTest(String username,String password,boolean expected) &#123; this.username = username; this.password = password; this.expected = expected; &#125; @Test public void testLogOn() &#123; assertEquals(expected,register.LogOn(username,password)); &#125; &#125; （二）执行结果执行了3次登录操作，并且验证结果同预置结果相同。 img 任务步骤按照上面讲解的参数化知识，按照要求给下面的代码段设计测试类，写出测试方法并执行测试。 要求如下： 使用条件组合覆盖来设计数据和测试方法。 12345678910111213141516public class Function &#123; public int function(int x, int y, int z) &#123; &#123; if ((y &gt; 1) &amp;&amp; (z == 0)) &#123; x = x / y; return x; &#125; if ((y == 2) || (x &gt; 1)) &#123; x = x + 1; return x; &#125; y = x + z; return y; &#125; &#125;&#125; 任务总结通过本次实训，完成JUnit中参数化的使用，为进行白盒测试奠定基础。实训难度较低，知识点主要在于参数化的使用，要求学生熟练掌握JUnit的参数化设置过程和方法知识点。 15）JUnit测试套件背景知识在前面的实训讲解中，我们执行测试类都是一个一个单独运行的，但是在实际项目实践中，测试类会非常的多，一个一个的单独执行是不可行的，为了解决这个问题，JUnit提供了一种批量运行测试类的方法，叫做测试套件。 通常把一组相关的测试称为一个测试套件（test suite）。测试套件会将类似测试用例集合在一起，例如测试套件可以是一个只包含冒烟测试测试用例的测试套件，或者是针对系统特定功能的测试套件。一个测试套件也可以包括所有的测试，并且标明其用途为冒烟测试或是针对特定的功能。 使用测试套件之后，每次验证系统功能正确性时，只需要执行一个或几个测试套件就可以。编写测试套件的方法比较简单，需要遵循以下规则： 1、创建一个空类作为测试套件的入口 2、使用注解org.junit.runner.RunWith和org.junit.runners.Suite.SuiteClasses修饰这个空类 3、将org.junit.runners.Suite作为参数传入注释RunWith，以提示JUnit为此类使用条件运行器执行。 4、将需要放入此测试套件的测试类组成数组作为注解SuiteClasses的参数。 5、保证这个空类使用public修饰，并且存在公开的不带有任何参数的构造函数。 （一）组合一组测试类1、准备测试类一，代码段：（实训9 参数化设置中的代码段） 1234567891011121314151617181920212223242526272829303132333435import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; @RunWith(Parameterized.class)public class RegisterTest &#123; private Register register = new Register(); private String username; private String password; private boolean expected; //测试数据集合，方法名可以随意定义，返回类型可变，但是必须用@Parameters标注 @Parameters public static Collection userData() &#123;// 数组中,包含了传入参数和期望结果，数组参数顺序与构造函数参数顺序一致即可 return Arrays.asList(new Object[][]&#123; &#123;&quot;Admin&quot;,&quot;123456&quot;,true&#125;, &#123;&quot;student&quot;,&quot;123456&quot;,false&#125;, &#123;&quot;Admin&quot;,&quot;123&quot;,false&#125;&#125;); &#125; //构造函数，参数赋值顺序与测试数据集合一致 public RegisterTest(String username,String password,boolean expected) &#123; this.username = username; this.password = password; this.expected = expected; &#125; @Test public void testLogOn() &#123; assertEquals(expected,register.LogOn(username,password)); &#125; &#125; 2、准备测试类二，代码段：（实训6 断言方法assertThat数值相关匹配符中的代码段） 1234567891011121314151617181920212223242526import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import org.junit.Before;import org.junit.Test;public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Before public void setUp() throws Exception &#123; ass.clear(); &#125; @Test public void testDiv() &#123; ass.div(20, 3); //closeTo：计算结果值在6.0±0.8范围内，测试通过 assertThat(ass.getResult(), closeTo(6.0, 0.8)); //greaterThan：计算结果值大于6时，测试通过 assertThat(ass.getResult(), greaterThan(6.0)); //lessThan：计算结果值小于8时，测试通过 assertThat(ass.getResult(), lessThan(8.0)); //greaterThanOrEuqalTo：计算结果值大于等于6.6时，测试通过 assertThat(ass.getResult(), greaterThanOrEqualTo(6.6)); //lessThanOrEqualTo：计算结果值小于等于6.7时，测试通过 assertThat(ass.getResult(), lessThanOrEqualTo(6.7)); &#125;&#125; 这边的目的准备好执行的代码，可以为其他的东西，只要是能用的就可以 3、新建测试套件类 （1）在该项目上点右键，选择“New”—-&gt;“Other”。如下图所示： img 这里是在测试类的包里面新建测试类 而不是在项目路径下，在pockage 。？？？ （2）在“New”窗口，选择“JUnit”—&gt;“JUnit Test Suite”，点“Next&gt;”。如下图所示： img （3）在“New JUnit Test Suite”窗口中，可以设置测试套件的类名称，选择该测试套件需要的测试类，我们选择RegisterTest 和AssertThatTest ，测试套件的类名称：AllTests，点“Finish”。如下图所示： img pockage！！！ （4）测试套件类生成代码段如下： 123456789import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class)@SuiteClasses(&#123; AssertThatTest.class, RegisterTest.class &#125;)public class AllTests &#123; &#125; 4、执行测试套件类，运行结果如下： 具体的测试结果在进度条上面有表示“共进行了4个测试”，4个均测试通过。 img ​ 在上面的步骤中，是将2个测试类放入了一个测试套件AllTests中，在Eclipse中运行这个测试套件，测试套件中的2个测试类都被执行了。测试套件中不仅可以包含基本的测试类，而且可以包含其他的测试套件，这样能方便的分层管理不同模块的单元测试代码。 （二）组合一组测试集1、测试套件一“AllTests1.java”，包含的测试类为：“AssertThatTest.class”、“RegisterTest.class”。代码段如下： 123456789import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class)@SuiteClasses(&#123; AssertThatTest1.class, TTest.class &#125;)public class AllTests2 &#123; &#125; 2、测试套件二“AllTests2.java”，包含的测试类为：“AssertThatTest1.class”、“TTest.class”。代码段如下： 123456789import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class)@SuiteClasses(&#123; AssertThatTest1.class, TTest.class &#125;)public class AllTests2 &#123; &#125; 3、按照上面的步骤新建测试套件，测试套件名称为“AllTests”，选择测试套件一“AllTests1.java”和测试套件二“AllTests2.java”。代码段如下： 123456789import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses; @RunWith(Suite.class)@SuiteClasses(&#123; AllTests1.class, AllTests2.class &#125;)public class AllTests &#123; &#125; 4、执行测试套件类，运行结果如下： 具体的测试结果在进度条上面有表示“共进行了7个测试”，7个均测试通过。 img 如果执行的测试类中有的测试用例重复 那么只会在最后一个测试集中被测试 image-20221105163106785 3 任务步骤 按照上面的JUnit测试套件知识讲解，使用JUnit测试套件完成下面的测试要求。 1、新建一个测试套件“AllTest1.java”运行2个测试类，测试类分别为： “实训4 JUnit断言方法-assertThat-一般匹配符”任务的测试类和“实训5 JUnit断言方法-assertThat-字符串相关匹配符”任务的测试类。 新建一个测试套件“AllTest2.java”运行2个测试类，测试类分别为： “实训6 JUnit 4 任务总结 通过本次实训，完成JUnit测试套件的使用，为进行白盒测试奠定基础。实训难度较低，知识点主要在于JUnit测试套件的理解和使用，要求学生熟练掌握JUnit测试套件相关的知识点。 16）JUnit测试优先级顺序​ 在JUnit测试执行过程中，我们发现JUnit执行测试方法的顺序并不是按照测试类中写好的测试方法顺序来执行。在实际过程如果测试方法有执行的先后，比如在测试数据库相关的用例时候，按照插入数据，查询数据和删除数据的顺序来执行测试方法。如果未指定顺序，可能会先删除，那么测试就会不通过。 JUnit提供了@FixMethodOrder注解来控制测试方法的执行顺序。提供了3种执行顺序类型。 ① MethodSorters.JVM：按照JVM得到的方法顺序，也就是代码中定义的方法顺序； ② MethodSorters.DEFAULT：JUnit默认的执行顺序； ③ MethodSorters.NAME_ASCENDING：按照方法名的字母顺序执行。 （一）被测代码段123456789101112131415161718192021public class Calculator &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void substract(int m, int n) &#123; result = m - n; &#125; public void multiply(int m, int n)&#123; result = m * n; &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; （二）默认执行顺序1、默认执行顺序测试类代码段 12345678910111213141516171819202122232425262728293031323334353637import static org.junit.Assert.*;import org.junit.Before;import org.junit.FixMethodOrder;import org.junit.Test;import org.junit.runners.MethodSorters; public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @Before public void setUp() throws Exception &#123; calculator.clear(); &#125; @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125; @Test public void testMultiply() &#123; calculator.multiply(5,5); assertEquals(25, calculator.getResult()); &#125; @Test public void testDivide() &#123; calculator.divide(8,2); assertEquals(4, calculator.getResult()); &#125;&#125; 2、默认执行顺序结果 img （三）使用MethodSorters.JVM1、使用MethodSorters.JVM顺序测试类代码段： 123456789101112131415161718192021222324252627282930313233343536373839import static org.junit.Assert.*;import org.junit.Before;import org.junit.FixMethodOrder;import org.junit.Test;import org.junit.runners.MethodSorters;@FixMethodOrder(MethodSorters.JVM)public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @Before public void setUp() throws Exception &#123; calculator.clear(); &#125; @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125; @Test public void testMultiply() &#123; calculator.multiply(5,5); assertEquals(25, calculator.getResult()); &#125; @Test public void testDivide() &#123; calculator.divide(8,2); assertEquals(4, calculator.getResult()); &#125;&#125; &#125; 2、使用MethodSorters.JVM顺序执行结果，结果按照代码段中的测试方法的顺序执行。 img （四）使用MethodSorters.DEFAULT1、使用MethodSorters.DEFAULT顺序测试类代码段： 1234567891011121314151617181920212223242526272829303132333435363738import static org.junit.Assert.*;import org.junit.Before;import org.junit.FixMethodOrder;import org.junit.Test;import org.junit.runners.MethodSorters;@FixMethodOrder(MethodSorters.DEFAULT)public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @Before public void setUp() throws Exception &#123; calculator.clear(); &#125; @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125; @Test public void testMultiply() &#123; calculator.multiply(5,5); assertEquals(25, calculator.getResult()); &#125; @Test public void testDivide() &#123; calculator.divide(8,2); assertEquals(4, calculator.getResult()); &#125;&#125;&#125; 2、使用MethodSorters.DEFAULT顺序执行结果，结果随机执行。 img （五）使用MethodSorters.NAME_ASCENDING1、使用MethodSorters.NAME_ASCENDING顺序测试类代码段： 12345678910111213141516171819202122232425262728293031323334353637import static org.junit.Assert.*;import org.junit.Before;import org.junit.FixMethodOrder;import org.junit.Test;import org.junit.runners.MethodSorters;@FixMethodOrder(MethodSorters.NAME_ASCENDING)public class CalculatorTest &#123; private static Calculator calculator = new Calculator(); @Before public void setUp() throws Exception &#123; calculator.clear(); &#125; @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125; @Test public void testMultiply() &#123; calculator.multiply(5,5); assertEquals(25, calculator.getResult()); &#125; @Test public void testDivide() &#123; calculator.divide(8,2); assertEquals(4, calculator.getResult()); &#125;&#125; 2、使用MethodSorters.NAME_ASCENDING顺序执行结果，结果按照代码段中的测试方法的字母顺序执行。 img 任务步骤按照上面的JUnit测试执行顺序的知识讲解，使用JUnit测试执行顺序完成下面的测试要求。 使用下面的被测段，编写测试类，练习MethodSorters.JVM、MethodSorters.DEFAULT、MethodSorters.NAME_ASCENDING执行测试类方法。 12345678910111213141516171819202122public class Calculator&#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void substract(int m, int n) &#123; result = m - n; &#125; public void multiply(int m, int n)&#123; result = m * n; &#125; public void divide(int m, int n) &#123; result = m / n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125;&#125; 任务总结通过本次实训，完成JUnit测试执行顺序的使用，为进行白盒测试奠定基础。实训难度较低，知识点主要在于JUnit测试执行顺序的理解和使用，要求学生熟练掌握JUnit测试执行顺序相关的知识点。 17）JUnit TestRunner使用背景知识​ 在前面的JUnit的学习过程中，了解了JUnit核心的测试类（TestCase）、测试集（TestSuite），本指导书主要讲解JUnit核心的测试运行器（TestRunner）。 ​ 在JUnit测试执行过程中，我们把测试代码提交给JUnit框架后，框架是通过什么来运行代码呢？答案就是TestRunner。TestRunner就是执行测试集的程序，在JUnit中有很多TestRunner，它们负责调用测试代码，每一个TestRunner都有自己的特殊功能，在实际使用中，我们需要根据不同的要求来选择不同的TestRunner。使用测试运行器的的方式也比较简单，主要使用JUnit的@RunWith注解。 在前面的学习中，大部分的测试都未指定TestRunner，但是也能正常执行。这是因为如果未指定TestRunner，那么执行时JUnit会自动使用默认的Runner，即BlockJUnit4ClassRunner。 JUnit包含的测试运行器： （1）JUnit38ClassRunner：为了兼容JUnit3.8的运行器 （2）BlockJunit4ClassRunner：JUnit4的默认测试运行器 （3）Parameterized：参数化测试，使用不同参数来运行相同测试集的运行器。 （4）Suite：实现打包测试。新建一个类把很多测试类放在一起，执行这个新建的类，就会把所有的测试类一起执行。 （5）Categories：分类执行，可以使用Categories运行器来制定一组测试被包含或排除。 （一）JUnit4默认Runner ​ 在代码中如未指定Runner，执行的时候就使用默认的Runner。默认执行器叫BlockJUnit4ClassRunner。 代码段： 12345678910111213141516171819import static org.junit.Assert.*; import org.junit.Test; public class Calculator01MainTest2 &#123; private static Calculator01Main calculator = new Calculator01Main(); @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125;&#125; 这段代码相当于下面的加了@RunWith注释的代码段： 12345678910111213141516171819202122import static org.junit.Assert.*; import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner; @RunWith(BlockJUnit4ClassRunner.class)public class Calculator01MainTest2 &#123; private static Calculator01Main calculator = new Calculator01Main(); @Test public void testAdd() &#123; calculator.add(3, 4); assertEquals(7, calculator.getResult()); &#125; @Test public void testSubstract() &#123; calculator.substract(10,3); assertEquals(7, calculator.getResult()); &#125;&#125; （二）Parameterized 在JUnit参数化设置指导书中已经介绍。 （三）Suite 实训10 JUnit测试套件指导书中已经介绍。 （四）Categories Categories是分类执行，比如有2个测试类A.java、B.java。A.java中有2个方式**A.a()、A.b()，B.java中有2个方式B.c()、B.d()，我们有一个类来执行这两个类的test case，但是只执行A.a()、B.c()，不执行A.b()、B.d()**，就可以使用Categories来达成目的。 Categories进行分类测试步骤： 1、创建接口 我们创建了2个接口用于测试方法的分类，一个方法为ClassifyOTests.java，一个方法为ClassifyTTests.java。 ClassifyOTests.java代码段 123public interface ClassifyOTests &#123; &#125; ClassifyTTests.java代码段 123public interface ClassifyTTests &#123; &#125; 2、准备的测试类一 ​ 测试类AssertionsTest 中添加Categories注释，将整个类前添加Category注释，注释@Category(ClassifyOTests.class)。 1234567891011121314151617181920212223242526272829303132333435import static org.junit.Assert.*;import org.junit.Test;import org.junit.experimental.categories.Category; @Category(ClassifyOTests.class)public class AssertionsTest &#123; @Test public void testAssertArrayEquals() &#123; int[] expected = &#123; 3 &#125;; int[] actual = &#123; 3 &#125;; assertArrayEquals(&quot;failure - not same&quot;, expected, actual); &#125; @Test public void testAssertEquals() &#123; long long1 = 50; long long2 = 50; assertEquals(&quot;failure - not same&quot;, long1, long2); &#125; @Test public void testAssertSame() &#123; String str1 = &quot;hello world!!&quot;; String str2 = &quot;hello world!!&quot;; assertSame(&quot;failure - not same&quot;, str2, str1); &#125; @Test public void testAssertNotSame() &#123; String str1 = &quot;hello world!!&quot;; String str2 = &quot;hello java!!&quot;; assertNotSame(&quot;failure - same&quot;, str1, str2); &#125;&#125; 3、准备的测试类二 需测试类代码段： 123456789101112131415public class AssertThat &#123; private static int result; public void add(int m, int n) &#123; result = m + n; &#125; public void clear() &#123; result = 0; &#125; public int getResult() &#123; return result; &#125; public String getName(String name) &#123; return name; &#125; &#125; 测试类代码段： （1）测试类AssertThatTest 中添加Categories注释，在测试方法前添加Category注释； （2）**testAdd()**方法添加注释@Category(ClassifyOTests.class)； （3）**testAdd1()**方法添加注释@Category(ClassifyOTests.class)； （4）testGetName方法添加注释@Category(ClassifyTTests.class)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import org.junit.Before;import org.junit.Test;import org.junit.experimental.categories.Category; public class AssertThatTest &#123; private static AssertThat ass = new AssertThat(); @Before public void setUp() throws Exception&#123; ass.clear(); &#125; @Test @Category(ClassifyOTests.class) public void testAdd() &#123; ass.add(3, 4); //allOf：所有条件必须都成立，测试才通过 ，结果在6和8之间 assertThat(ass.getResult(), allOf(greaterThan(6), lessThan(8))); //anyOf只要有一个条件成立，测试就通过 assertThat(ass.getResult(), anyOf(greaterThan(6), lessThan(5))); //anyOf只要有一个条件成立，测试就通过 assertThat(ass.getResult(), anyOf(greaterThan(8), lessThan(9))); //anything：无论什么条件，测试都通过 assertThat(ass.getResult(), anything()); &#125; @Test @Category(ClassifyOTests.class) public void testAdd1() &#123; ass.add(3, 4); //is：变量的值等于指定值时，测试通过 assertThat(ass.getResult(), is(7)); //not：和is相反，变量的值不等于指定值时，测试通过 assertThat(ass.getResult(), not(2)); //euqalTo：相加结果为7，测试通过 assertThat(ass.getResult(), equalTo(7)); &#125; @Test @Category(ClassifyTTests.class) public void testGetName() &#123; //containsString：字符串变量中包含指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), containsString(&quot;ni&quot;)); //startsWith：字符串变量以指定字符串开头时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), startsWith(&quot;Mo&quot;)); //endsWith：字符串变量以指定字符串结尾时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), endsWith(&quot;ka&quot;)); //euqalTo：字符串变量等于指定字符串时，测试通过 assertThat(ass.getName(&quot;Monika&quot;), equalTo(&quot;Monika&quot;)); &#125;&#125; 4、添加测试集类（方法一） 要求：只执行标注了@Category(ClassifyOTests.class)的方法和类，@IncludeCategory标注要执行的那个分类的方法。第一种书写方法： 12345678910import org.junit.experimental.categories.Categories;import org.junit.experimental.categories.Categories.IncludeCategory;import org.junit.runner.RunWith;import org.junit.runners.Suite.SuiteClasses; @RunWith(Categories.class)@IncludeCategory(ClassifyOTests.class)@SuiteClasses(&#123; AssertionsTest.class, AssertThatTest.class &#125;)public class AllTests &#123; &#125; 5、方法一执行结果 只执行标注了@Category(ClassifyOTests.class)的方法和类，执行结果。AssertionsTest 整个类标注@Category(ClassifyOTests.class)，这个类的所有方法都执行。AssertThatTest 执行标注了@Category(ClassifyOTests.class)的testAdd()和testAdd1()方法，testGetName()方法未执行。 img 6、添加测试集类（方法二） 只执行标注了@Category(ClassifyOTests.class)的方法和类。第二种书写方法，ExcludeCategory(ClassifyOTests.class)除了运行ClassifyOTests方法之外的方法都运行： 123456789101112import org.junit.experimental.categories.Categories;import org.junit.experimental.categories.Categories.ExcludeCategory;import org.junit.runner.RunWith;import org.junit.runners.Suite.SuiteClasses; @RunWith(Categories.class)@ExcludeCategory(ClassifyTTests.class)@SuiteClasses(&#123; AssertionsTest.class, AssertThatTest.class &#125;)public class AllTests &#123; &#125; 7、方法二执行结果 img 任务步骤按照上面的JUnit测试套件知识讲解，使用JUnit测试套件完成下面的测试要求。 1、新建两个接口CalculatorOTest.java、CalculatorTTest.java。 2、测试类1为： “实训4 JUnit断言方法-assertThat-一般匹配符”任务的测试类，减法测试为CalculatorOTest分类，除法测试为CalculatorTTest分类。 3、测试类2为“实训5 JUnit断言方法-assertThat-字符串相关匹配符”任务的测试类，姓名判断测试为CalculatorOTest分类，年龄测试为CalculatorTTest分类。 4、新建一个测试集“CategoryTestO.java”运行上面2个测试类，只运行CalculatorOTest分类方法。 5、新建一个测试集“CategoryTestT.java”运行上面2个测试类，运行除了CalculatorOTest分类之外的方法。 任务总结通过本次实训，完成JUnit中TestRunner的使用，为进行白盒测试奠定基础。实训难度较低，知识点主要在于JUnit中BlockJunit4ClassRunner、Parameterized、Suite、Categories运行器的理解和使用，要求学生掌握JUnit运行器相关的知识点。 18）JUnit内置Rule中TestName使用JUnit Rule提供了很多实用的内置Rule，下面介绍TestName Rule，TestName支持在测试中获取当前测试方法的名称。（一）代码段：使用TestName获取每个测试方法名称。 1234567891011121314import org.junit.*;import org.junit.rules.TestName;public class testTestName &#123; @Rule public TestName name = new TestName(); @Test public void testA() &#123; System.out.println(&quot;This method name &quot;+name.getMethodName()); &#125; @Test public void testB() &#123; System.out.println(&quot;This method name &quot;+name.getMethodName()); &#125;&#125; （二）打印结果： 12This method name testAThis method name testB 19）JUnit内置Rule中TemporaryFolder使用（一）随机生成文件名称代码段：1、使用上面介绍的3个方法创建随机文件和文件夹，以及递归创建文件夹“a&#x2F;b&#x2F;c”。 123456789101112131415161718192021import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class TempMain &#123;// 使用系统临时目录@Rule public TemporaryFolder temporaryFolder = new TemporaryFolder(); @Test public void temporaryFolderTest() throws IOException, InterruptedException &#123;//创建一个随机名字的新文件 File createFile=temporaryFolder.newFile();//创建一个随机名字的新文件夹 File createFolder=temporaryFolder.newFolder();//递归地创建指定名字的新文件夹 File createFolders = temporaryFolder.newFolder(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//打印文件地址 System.out.println(createFile.getPath()); System.out.println(createFolder.getPath()); System.out.println(createFolders.getPath());//判断文件是否存在 assertTrue(createFolder.exists()); assertTrue(createFile.exists()); assertTrue(createFolders.exists()); &#125;&#125; 2、打印结果：创建的文件和文件夹都放在系统默认临时文件目录中，未写明文件和文件夹名称创建时的命名是系统随机的文件和文件名。递归地创建指定名字的新文件夹，在文件夹 a 下面创建文件夹b，在文件夹b下面创建文件夹 c。 123C:\\Users\\1\\AppData\\Local\\Temp\\junit9928123292388311888\\junit8891983687442144273.tmpC:\\Users\\1\\AppData\\Local\\Temp\\junit9928123292388311888\\junit2702644746921779870C:\\Users\\1\\AppData\\Local\\Temp\\junit9928123292388311888\\a\\b\\c （二）指定文件路径和名称代码段：1、指定临时文件保存的目录为“E:\\test”，创建临时文件夹temporary，创建临时文件temporary.txt。 12345678910111213141516171819import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class TemporaryFolderMain &#123;//在构造方法上加入路径参数来指定临时目录 @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder(new File(&quot;E:\\\\test&quot;)); @Test public void temporaryFolderTest() throws IOException, InterruptedException &#123;//创建一个名字为“temporary.txt&quot;”的新文件 File createFile=temporaryFolder.newFile(&quot;temporary.txt&quot;);//创建一个名字为“temporary”的新文件夹 File createFolder=temporaryFolder.newFolder(&quot;temporary&quot;);//打印文件地址 System.out.println(createFile.getPath()); System.out.println(createFolder.getPath());//判断文件是否存在 assertTrue(createFolder.exists()); assertTrue(createFile.exists()); &#125;&#125; 2、打印结果：创建的文件和文件夹都放在指定目录中。 12E:\\test\\junit13737043164201729769\\temporary.txtE:\\test\\junit13737043164201729769\\temporary 20）JUnit内置Rule中ExternalResource使用JUnit的@ClassRule-ExternalResource使用​ （一）ExternalResource用在@ClassRule注解字段中：1、本实例需要做的操作是连接数据库，对数据库中的数据进行操作。使用的是MySql数据库，数据库版本是8.0版本。2、数据库内容：数据库名称“test”；数据库用户名为“root”，密码为“123”；学生表名称“students”；学生表字段名称和数据如下： id name gender grade score 1 小张 1 1 88 2 小王 1 1 95 3 小红 0 1 93 4 小白 0 1 100 5 小花 1 2 96 6 小鱼 1 2 99 7 小飞 0 2 86 8 小乔 0 2 79 9 小青 1 3 85 10 小栗 1 3 90 11 晓晓 0 3 91 12 小贝 0 3 77 3、要进行数据库连接操作，先需要在Eclipse项目中引入MySQL驱动包版本。mysql-connector-java-8.0.16.jar4、被测代码段。 1234567891011121314151617181920212223242526272829303132333435363738394041package junitA;import static org.junit.Assert.assertTrue;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class a123 &#123;// 查询所有学生名称 List&lt;String&gt; queryAllStudents(Connection conn) throws SQLException &#123; List&lt;String&gt; students = new ArrayList&lt;&gt;(); try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT name FROM students&quot;)) &#123; try (ResultSet rs = ps.executeQuery()) &#123; while (rs.next()) &#123; students.add(extractRow(rs)); &#125; &#125; &#125; return students; &#125;// 查询grade=1，score大于等于96的学生名称 List&lt;String&gt; queryStudents(Connection conn) throws SQLException &#123; List&lt;String&gt; students = new ArrayList&lt;&gt;(); try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT name FROM students WHERE grade = ? AND score &gt;= ?&quot;)) &#123; ps.setInt(1, 1); // 第一个参数grade=? ps.setInt(2, 96); // 第二个参数score=? try (ResultSet rs = ps.executeQuery()) &#123; while (rs.next()) &#123; students.add(extractRow(rs)); &#125; &#125; &#125; return students; &#125;// 查询结果整理 static String extractRow(ResultSet rs) throws SQLException &#123; return String.format(&quot;%s&quot;, rs.getString(&quot;name&quot;)); &#125;&#125; 5、测试代码段：使用ExternalResource用在@ClassRule注解字段中，before()打开数据库连接，after()关闭数据库连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.ClassRule;import org.junit.Test;import org.junit.rules.ExternalResource;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;public class JDBCMainTest &#123; private static JDBCMain student = new JDBCMain(); private static String jdbcUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;; private static String jdbcUsername = &quot;root&quot;; private static String jdbcPassword = &quot;123&quot;; private static Connection conn = null; @ClassRule public static ExternalResource external = new ExternalResource() &#123; protected void before() throws SQLException &#123; try &#123; System.out.println(&quot;连接数据库...&quot;); conn = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125; protected void after() &#123; try &#123; System.out.println(&quot;关闭数据库连接...&quot;); conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125; &#125;; @BeforeClass public static void setUpBeforeClass() throws Exception &#123; System.out.println(&quot;@BeforeClass&quot;); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; System.out.println(&quot;@AfterClass&quot;); &#125; @Before public void setUp() throws Exception &#123; System.out.println(&quot;@Before&quot;); &#125; @After public void tearDown() throws Exception &#123; System.out.println(&quot;@After&quot;); &#125; @Test public void testQueryAllStudents() throws SQLException &#123; System.out.println(&quot;testQueryAllStudents&quot;);// 判断查询出的名称信息是否正确 assertThat(student.queryAllStudents(conn), containsInAnyOrder(&quot;小张&quot;, &quot;小王&quot;, &quot;小红&quot;, &quot;小白&quot;, &quot;小花&quot;, &quot;小鱼&quot;, &quot;小飞&quot;, &quot;小乔&quot;, &quot;小青&quot;, &quot;小栗&quot;, &quot;晓晓&quot;, &quot;小贝&quot;)); &#125; @Test public void testQueryStudents() throws SQLException &#123; System.out.println(&quot;testQueryStudents&quot;);//判断查询出的名称信息是否正确 assertThat(student.queryStudents(conn), hasItem(&quot;小白&quot;)); &#125;&#125; 6、测试打印结果： 12345678910连接数据库...@BeforeClass@BeforetestQueryAllStudents@After@BeforetestQueryStudents@After@AfterClass关闭数据库连接... JUnit的@Rule-ExternalResource使用（一）ExternalResource用在@Rule注解字段中：1、数据库内容：数据库名称“test”；数据库用户名为“root”，密码为“123”；学生表名称“students”；学生表字段名称和数据如下： id name gender grade score 1 小张 1 1 88 2 小王 1 1 95 3 小红 0 1 93 4 小白 0 1 100 5 小花 1 2 96 6 小鱼 1 2 99 7 小飞 0 2 86 8 小乔 0 2 79 9 小青 1 3 85 10 小栗 1 3 90 11 晓晓 0 3 91 12 小贝 0 3 77 2、被测代码段。 123456789101112131415161718192021222324252627282930313233343536373839import static org.junit.Assert.assertTrue;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class JDBCMain &#123;// 查询所有学生名称 List&lt;String&gt; queryAllStudents(Connection conn) throws SQLException &#123; List&lt;String&gt; students = new ArrayList&lt;&gt;(); try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT name FROM students&quot;)) &#123; try (ResultSet rs = ps.executeQuery()) &#123; while (rs.next()) &#123; students.add(extractRow(rs)); &#125; &#125; &#125; return students; &#125;// 查询grade=1，score大于等于96的学生名称 List&lt;String&gt; queryStudents(Connection conn) throws SQLException &#123; List&lt;String&gt; students = new ArrayList&lt;&gt;(); try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT name FROM students WHERE grade = ? AND score &gt;= ?&quot;)) &#123; ps.setInt(1, 1); // 第一个参数grade=? ps.setInt(2, 96); // 第二个参数score=? try (ResultSet rs = ps.executeQuery()) &#123; while (rs.next()) &#123; students.add(extractRow(rs)); &#125; &#125; &#125; return students; &#125;// 查询结果整理 static String extractRow(ResultSet rs) throws SQLException &#123; return String.format(&quot;%s&quot;, rs.getString(&quot;name&quot;)); &#125;&#125; 3、测试代码段：使用ExternalResource用在@Rule注解字段中，before()打开数据库连接，after()关闭数据库连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.*;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import org.junit.After;import org.junit.AfterClass;import org.junit.Before;import org.junit.BeforeClass;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExternalResource;public class JDBCMainTest2 &#123; private static JDBCMain student = new JDBCMain(); private static String jdbcUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;; private static String jdbcUsername = &quot;root&quot;; private static String jdbcPassword = &quot;123&quot;; private static Connection conn = null; @Rule public ExternalResource external = new ExternalResource() &#123; protected void before() throws SQLException &#123; try &#123; System.out.println(&quot;连接数据库...&quot;); conn = DriverManager.getConnection(jdbcUrl, jdbcUsername, jdbcPassword); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125; protected void after() &#123; try &#123; System.out.println(&quot;关闭数据库连接...&quot;); conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; &#125; &#125;; @BeforeClass public static void setUpBeforeClass() throws Exception &#123; System.out.println(&quot;@BeforeClass&quot;); &#125; @AfterClass public static void tearDownAfterClass() throws Exception &#123; System.out.println(&quot;@AfterClass&quot;); &#125; @Before public void setUp() throws Exception &#123; System.out.println(&quot;@Before&quot;); &#125; @After public void tearDown() throws Exception &#123; System.out.println(&quot;@After&quot;); &#125; @Test public void testQueryAllStudents() throws SQLException &#123; System.out.println(&quot;testQueryAllStudents&quot;); assertThat(student.queryAllStudents(conn), containsInAnyOrder(&quot;小张&quot;, &quot;小王&quot;, &quot;小红&quot;, &quot;小白&quot;, &quot;小花&quot;, &quot;小鱼&quot;, &quot;小飞&quot;, &quot;小乔&quot;, &quot;小青&quot;, &quot;小栗&quot;, &quot;晓晓&quot;, &quot;小贝&quot;)); &#125; @Test public void testQueryStudents() throws SQLException &#123; System.out.println(&quot;testQueryStudents&quot;); assertThat(student.queryStudents(conn), hasItem(&quot;小白&quot;)); &#125;&#125; 4、测试结果打印： 123456789101112@BeforeClass连接数据库...@BeforetestQueryAllStudents@After关闭数据库连接...连接数据库...@BeforetestQueryStudents@After关闭数据库连接...@AfterClass 21）JUnit测试private方法。JUnit的间接测试private方法下面介绍间接测试方法进行private方法的测试。1、需测试类代码段： 1234567891011121314151617181920212223public class Register &#123; public boolean LogOn(String username, String password) &#123; Register register = new Register(); if (register.userName(username) &amp;&amp; register.passWord(password)) &#123; return true; &#125; return false; &#125; private boolean userName(String username) &#123; if (username == &quot;Admin&quot;) &#123; return true; &#125; return false; &#125; private boolean passWord(String password) &#123; if (password == &quot;123456&quot;) &#123; return true; &#125; return false; &#125;&#125; 2、编写测试类代码段： 1234567891011import static org.junit.Assert.*;import org.junit.Test;public class RegisterTest &#123; private static Register register = new Register(); @Test public void test() &#123; assertEquals(true, register.LogOn(&quot;Admin&quot;, &quot;123456&quot;)); &#125;&#125; 如上所述，userName和passWord为private方法，在类中被LogOn调用。通过测试LogOn来间接的测试userName和passWord。对LogOn进行测试时，使用不同的测试数据可以覆盖userName和passWord的测试需求。 JUnit使用反射机制测试private方法下面介绍使用Java的反射机制进行private方法的测试。1、需测试类代码段： 1234567891011121314151617181920212223public class Register &#123; private boolean LogOn(String username, String password) &#123; Register register = new Register(); if (register.userName(username) &amp;&amp; register.passWord(password)) &#123; return true; &#125; return false; &#125; private boolean userName(String username) &#123; if (username == &quot;Admin&quot;) &#123; return true; &#125; return false; &#125; private boolean passWord(String password) &#123; if (password == &quot;123456&quot;) &#123; return true; &#125; return false; &#125;&#125; 2、编写测试类代码段： 12345678910111213141516171819202122232425262728293031323334353637import static org.junit.Assert.*;import java.lang.reflect.Method;import org.junit.Test;public class RegisterTest &#123; private static Register register = new Register(); private Object result; @Test public void testLogOn() throws Exception &#123;// 获取私有方法和他的参数 Method method = register.getClass().getDeclaredMethod(&quot;LogOn&quot;, new Class[] &#123; String.class, String.class &#125;);// 值为true时 // 反射的对象在使用时 // 让一切已有的访问权限取消 method.setAccessible(true);// 通过invoke方法执行 result = method.invoke(register, new Object[] &#123; &quot;Admin&quot;, &quot;123456&quot; &#125;); assertEquals(true, result); &#125; @Test public void testUserName() throws Exception &#123;// 获取私有方法和他的参数 Method method = register.getClass().getDeclaredMethod(&quot;userName&quot;, String.class);// 值为true时 反射的对象在使用时 // 让一切已有的访问权限取消 method.setAccessible(true);// 通过invoke方法执行 result = method.invoke(register, new Object[] &#123; &quot;Admin&quot; &#125;); assertEquals(true, result); &#125; @Test public void testPassWord() throws Exception &#123;// 获取私有方法和他的参数 Method method = register.getClass().getDeclaredMethod(&quot;passWord&quot;, String.class);// 值为true时 反射的对象在使用时 // 让一切已有的访问权限取消 method.setAccessible(true);// 通过invoke方法执行 result = method.invoke(register, &quot;123456&quot;); assertEquals(true, result); &#125;&#125; Method method &#x3D; register.getClass().getDeclaredMethod(“LogOn”, new Class[] {String.class,String.class})；该语句为获取私有方法“LogOn”和他的参数， 通过 getDeclaredMethod方法获取到这个私有方法，第一个参数是方法名“LogOn”，第二个参数是LogOn中的2个参数的类型{String.class,String.class}。method.setAccessible(true)；设置constructors.setAccessible(true)时，可以调用私有方法。Object result &#x3D; method.invoke(register, new Object[] {“Admin”,”123456”})；是通过invoke实现方法执行，invoke需要两个参数一个是类的实例，一个是方法参数。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"单元测试","slug":"软件测试/单元测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"单元测试","slug":"单元测试","permalink":"http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-20T10:34:29.952Z","updated":"2022-10-20T10:34:29.952Z","comments":true,"path":"2022/10/20/hello-world/","link":"","permalink":"http://example.com/2022/10/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"在HEXO中添加新页面","slug":"hexo/在HEXO中添加新页面","date":"2022-10-19T11:30:37.000Z","updated":"2022-10-19T11:32:46.545Z","comments":true,"path":"2022/10/19/hexo/在HEXO中添加新页面/","link":"","permalink":"http://example.com/2022/10/19/hexo/%E5%9C%A8HEXO%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"}]},{"title":"自动化测试","slug":"软件测试/自动化测试","date":"2022-10-18T05:36:04.000Z","updated":"2022-10-30T04:26:01.916Z","comments":true,"path":"2022/10/18/软件测试/自动化测试/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","excerpt":"","text":"元素定位id定位 image-20221026094950071 从上面定位到的元素属性中可以看到有个id属性：id&#x3D;”username”，这里可以通过id属性定位到这个元素。定位到用户名输入框后，需要对其赋值，这里用send_keys( )方法进行文本输入。如果需要对其单击操作，可以使用click( )方法。格式：find_element_by_id(“”) 12345678910实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_id(&quot;username&quot;).send_keys(&quot; hrteacher&quot;)#通过id()方法定位页面元素，输入用户名 name定位 在编写自动化脚本的时候，如果页面中某个元素没有id属性，那就没有办法通过id属性定位页面元素，但是如果页面中存在唯一的name属性，那么就可以使用name元素来定位。以人力资源综合服务系统登录页面的用户名输入框为例，先打开人力资源系统登录页面，选择用户名输入框，右击查看元素，如图所示。 image-20221026095423400 从定位到的元素属性可以看到有个name属性：name&#x3D;”username”，这里可以通过其name属性定位到这个元素。定位到用户名输入框后，需要对其赋值。 12345678910实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#通过name()方法定位页面元素，输入用户名 xpath定位 xpath定位是一种路径定位方式，主要依赖元素通过绝对路径或者相关路径来定位，当进行手动编写路径的时候，由于绝对路径需要从头到尾一级一级地往下编写，当遇到元素路径比较深的时候，写起来很麻烦，而且容易出错，且绝对路径xpath执行效率比较低，一般使用比较少。通常使用xpath相对路径和属性定位。由于这里用到有关于网页元素的相关知识（即XML知识），因此下面对这些知识进行讲解。 12345678910111213我们将在下面的例子中使用如下XML文档。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt; 1）选取节点：xpath使用路径表达式在XML文档中选取节点，xpath路径表达式及其描述如表所示。 image-20221026095729734 2）选取未知节点：xpath通配符可用来选取未知的XML元素，xpath通配符及其描述，如表所示。 image-20221026095747661 image-20221026095757202 3）选取若干路径：通过在路径表达式中使用“|”运算符，可以选取若干路径。在表中列出了一些路径表达式及其结果。 image-20221026095834596 上面的定位方式都是通过元素的某个属性来定位的，还可以通过路径导航实现某个元素的定位，这个时候就可以用xpath解决。xpath是一种路径语言，除了上面讲到的手工编写外，还可以直接复制到xpath的路径，然后编写脚本。以人力资源综合服务系统登录页面为例，如图所示。格式：find_element_by_xpath(“”) image-20221026095859089 12345678910实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_css_selector(&#x27;#password&#x27;).send_keys(&quot;hrteacher&quot;)#通过css_selector()方法定位页面元素，输入用户名 css_selector定位 css_selector定位是另外一种通过路径导航实现某个元素的定位方法，此方法比xpath更为简洁，运行速度更快。可以通过定位到某个页面元素后，直接右击选择相应命令，然后进行脚本编写。以人力资源综合服务系统登录页面为例，如图所示。格式：find_element_by_css_selecto(“”) image-20221026095955998 1234567891011实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_css_selector(&#x27;#password&#x27;).send_keys(&quot;hrteacher&quot;)#通过css_selector()方法定位页面元素，输入用户名 link_text定位 link_text是根据超链接的文本来定位，如果要单击超链接文本，进行从一个页面跳转到另元素定位方外一个页面，那么可以使用此元素定位方式进行定位。以人力资源综合服务系统中的人资工作台按钮为例，右击查看元素，如图所示。通过元素属性可以分析出，当标签属性为a，且href &#x3D;”&#x2F;suthr&#x2F;home”，说明它是个超链接，对于这种元素，可以用link_text方法。格式：find_element_by_link_text(“”) image-20221026100033560 12345678910111213141516171819202122实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码；（3）单击“登录”按钮；（4）单击“人资工作台”按钮。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_id(&quot;loginBtn&quot;).click()#单击“登录”按钮文前-04.indd 155 2021-11-11 12:01:53Web 应用软件测试（中级） 156driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#通过link_text()方法定位页面元素，进入人资工作台页面 partial_link_text定位 上面讲的link_text定位方法是找到超链接文本进行定位，有时一个超链接文本的字符串可能比较长，如果输入全称，会显示很长，占用编写脚本地方，而且不好看，这时可以用partial_link_text定位。这是一种模糊匹配方式，只要截取超链接文本中一部分字符串即可。以人力资源综合服务系统中的人资工作台按钮为例，右击查看元素，如图所示。从图中可以看出，当要通过“人资工作台”进行定位的时候，只需输入“工作台”即可。格式：find_element_by_partial_link_text(“”) image-20221026100133687 12345678910111213141516171819实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码；（3）单击“登录”按钮；（4）单击“人资工作台”按钮。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_id(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_id(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_id(&quot;loginBtn&quot;).click()#单击“登录”按钮driver.find_element_by_partial_link_text(&quot;工作台&quot;).click()#通过partial_link_text()方法定位页面元素，进入人资工作台页面 class_name定位 在编写自动化脚本的时候，如果某个页面元素既没有id属性，也没有name属性，但可以在定位的页面中找到class&#x3D;””元素，那么就可以使用class_name元素实现定位。以人力资源综合服务系统页面左侧的“培训进修”按钮为例，右击查看元素，如图所示。从图中定位到的元素属性可以看到有个class属性：class&#x3D;”icon-badge”，这里可以通过它的class属性定位到这个元素。格式：find_element_by_class_name(“”) image-20221026100209167 12345678910111213141516171819实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码；（3）单击“登录”按钮；（4）单击页面左侧的“培训进修”按钮。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_id(&quot;loginBtn&quot;).click()#单击“登录”按钮driver.find_element_by_class_name(&quot;icon-badge&quot;).click()#通过class_name()方法定位页面元素，进入培训进修页面 特殊情况：在HTML脚本中，会出现class属性中出现空格的情况，如图所示。对于这种出现空格的情况，实际上是class属性中出现多个名字，空格前面一个名字，空格后面一个名字，在定位的时候用哪个名字都可以。 image-20221026100253396 1234567891011实例2：（1）进入人力资源综合服务系统登录页面；（2）输入用户名。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_class_name(&quot;form-control&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名 tag_name定位 HTML的本质就是通过tag来定义实现不同的功能，每一个元素本质上也是一个tag。tag往往用来定义一类功能，所以通过tag识别某个元素的概率很低，因此用得比较少。例如，页面中存在大量的、、等tag。以人力资源综合服务系统登录页面的“登录”按钮为例，先打开人力资源系统登录页面，选择“登录”按钮，右击查看元素，如图所示。从图中定位到的元素属性可以看到有个area属性：&lt;button type&#x3D;”submit” class&#x3D;”submit_btn”style&#x3D;””&gt;登录，area是页面中独一无二的元素，这里可以通过它的area属性定位到这个元素。 image-20221026100331104 1234567891011实例：（1）进入人力资源综合服务系统登录页面；（2）单击“登录”按钮。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_tag_name(&quot;button&quot;).click()#单击“登录”按钮 复数元素定位 八种基本定位方式对应的复数形式如下：● id复数定位find_elements_by_id( )；● name复数定位find_elements_by_name( )；● class复数定位find_elements_by_class_name( )；● tag复数定位find_elements_by_tag_name( )；● link复数定位find_elements_by_link_text( )；● partial_link复数定位find_elements_by_partial_link_text( )；● xpath复数定位find_elements_by_xpath( )；● css复数定位find_elements_by_css_selector( )。 这些复数定位方式每次取到的都是具有相同类型属性的一组元素，所以返回的是一个list队列，也可以利用这个队列去定位单个元素。以人力资源综合服务系统登录页面为例，如图所示。 从图中我们可以看出，用户名输入框和密码输入框都有共同的标签input。定位到的元素属性中可以看到用户名输入框在页面排第一个，通过复数定位的代码为：driver.find_elements_by_tag_name(“input”)[0].send_keys(“hrteacher”) image-20221026100504713 1234567891011121314实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名；（3）输入密码。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_elements_by_tag_name(&quot;input&quot;)[0].send_keys(&quot;hrteacher&quot;)#通过driver.find_elements_by_tag_name定位页面元素，输入用户名driver.find_elements_by_tag_name(&quot;input&quot;)[1].send_keys(&quot;123456&quot;)#通过driver.find_elements_by_tag_name定位页面元素，输入密码 鼠标操作 ActionChains基本能够满足所有对鼠标操作的需求。使用此类中的方法时，需要先引入此类，引入代码为：selenium.webdriver.common.action_chains.ActionChains(driver)需要了解ActionChains的执行原理，当调用ActionChains( )方法时，不会立即执行，而是会将所有的操作按顺序存放在一个队列里，当调用perform( )方法时，按照队列里面的顺序进行执行。其中调用的perform( )方法必须放在ActionChains方法最后。这种情况下可以有两种调用方法，两种写法本质是一样的，ActionChains都会按照顺序执行所有的操作。 12341．链式写法menu=driver.find_element_by_css_selector(&quot;.nav&quot;)hidden_submenu=driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform() 123456782．分步写法menu=driver.find_element_by_css_selector(&quot;.nav&quot;)hidden_submenu=driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)actions=ActionChains(driver)actions.move_to_element(menu)actions.click(hidden_submenu)actions.perform() 键盘操作 Keys基本能够满足对键盘基本操作的需求。模拟键盘的操作需要先引入键盘模块，引入脚本为：from selenium.webdriver.common.keys import Keys在使用Keys方法时，可以分为两大类： 1234（1）先使用ActionChains类将鼠标移动到需要进行键盘操作的位置，然后进行键盘操作，如以下代码：ActionChains(driver).send_keys(Keys.TAB).send_keys(Keys.ENTER).perform()#对定位到的元素进行回车操作 1234（2）先通过元素定位方式进行元素定位，然后通过send_keys()进行键盘操作，如以下代码：driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.ENTER)#模拟Enter键操作回车按钮 Keys方法列表如表所示。 image-20221026100726333 12345678910111213141516171819202122232425262728293031323334实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码，单击“登录”按钮；（3）单击系统页面中的“培训进修”按钮；（4）在培训内容输入框中输入信息dd；（5）全选信息；（6）复制信息；（7）粘贴信息两次；（8）过鼠标的形式单击“查询”按钮。在PyCharm中进行代码编写：import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;培训进修&quot;).click()#单击“培训进修”按钮driver.find_element_by_id(&quot;content&quot;).send_keys(&quot;dd&quot;)#在培训内容输入框输入信息time.sleep(3)driver.find_element_by_id(&quot;content&quot;).send_keys(Keys.CONTROL,&#x27;a&#x27;)time.sleep(3)#全选信息driver.find_element_by_id(&quot;content&quot;).send_keys(Keys.CONTROL,&#x27;c&#x27;)time.sleep(3)#复制信息driver.find_element_by_id(&quot;content&quot;).send_keys(Keys.CONTROL,&#x27;v&#x27;)time.sleep(3)#粘贴信息driver.find_element_by_id(&quot;content&quot;).send_keys(Keys.CONTROL,&#x27;v&#x27;)time.sleep(3)#粘贴信息ActionChains(driver).send_keys(Keys.TAB).send_keys(Keys.TAB).send_keys(Keys.TAB).send_keys(Keys.ENTER).perform()#单击“查询”按钮 时间等待方法 测试过程中，会发现脚本执行的时候展现出来的效果都是很快结束，此时可以增加一个等待时间来观察执行效果。这种等待时间只是为了便于观察，这种情况下是否包含等待时间不会影响执行结果，但是有一种情况会直接影响执行结果。在打开一个网站的时候，由于环境的因素导致页面没有加载完成，此时去定位元素无法找到元素，这种情况下增加等待时间就会显得万分重要。本任务针对时间等待处理进行介绍。 Selenium主要提供WebDriverWait和Implicit Wait两种模式的等待，但是Python time模块也提供一种非智能的sleep( )等待，使用这个设置以后必须强制等待设置的时间，只有等待时间结束才会继续执行。这种模式一般会用于观察执行效果的时候，而WebDriverWait和Implicit Wait这两种时间等待属于智能等待。 显式等待例如：element&#x3D;WebDriverWait(driver,10).until(lambda x: x.find_element_by_id(“someId”))is_disappeared&#x3D;WebDriverWait(driver,30,1,(ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(“someId”).is_displayed())注意：until是固定格式，可以理解为直到元素定位到为止；lambda x:x是一个匿名函数构建的方法，这里不太好理解，可以理解为固定格式，最后接定位方法。 12345例如：element=WebDriverWait(driver,10).until(lambda x: x.find_element_by_id(&quot;someId&quot;))is_disappeared=WebDriverWait(driver,30,1,(ElementNotVisibleException)).until_not(lambda x: x.find_element_by_id(&quot;someId&quot;).is_displayed())注意：until是固定格式，可以理解为直到元素定位到为止；lambda x:x是一个匿名函数构建的方法，这里不太好理解，可以理解为固定格式，最后接定位方法。 WebDriverWait( )一般由unit( )或until_not( )方法配合使用。● until(method, message=&#39;&#39;)调用该方法提供的驱动程序作为一个参数，直到返回值不为False；● until_not(method, message=&#39;&#39;)调用该方法提供的驱动程序作为一个参数，直到返回值为False。 12345678910111213141516171819实例1：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码；（3）单击“登录”按钮，设置时间等待。在PyCharm中进行代码编写：from selenium import webdriverfrom selenium.webdriver.support.wait import WebDriverWaitdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码element=WebDriverWait(driver,10).until(lambda x:x.find_element_by_id(&quot;loginBtn&quot;))#定位“登录”按钮并设置时间等待element.click()#单击“登录”按钮 强制等待设置等待最简单的方法就是强制等待，也就是sleep( )方法。它可以让程序暂停运行一定时间，时间过后继续运行。其缺点是不智能，如果设置的时间太短，元素还没有加载出来，则照样会报错；如果设置的时间太长，则会浪费时间。如果代码量过大，多个强制等待会影响整体的运行速度。 使用强制等待sleep( )需要导入sleep。代码如下：from time import sleep。使用格式：sleep() 12345678910111213141516171819实例2：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码，设置时间等待；（3）单击“登录”按钮。在PyCharm中进行代码编写：from time import sleepfrom selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码sleep(5)#时间等待driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮 隐式等待隐性等待就是设置一个等待时间范围，这个等待时间是不固定的，最长的等待时间是设置的最大值。隐性等待也称智能等待，是Selenium提供的一个超时等待。它等待一个元素被发现，或一个命令完成，如果超出设置时间则抛出异常。 使用格式：driver.implicitly_wait() 123456789101112131415161718实例3：（1）进入人力资源综合服务系统登录页面，设置时间等待；（2）输入用户名和密码；（3）单击“登录”按钮。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)#时间等待driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮 窗口切换有些页面的链接打开后会重新打开一个窗口，想在新页面上操作就得先切换窗口。获取窗口的唯一标识用句柄表示，所以只需要切换句柄，就能在多个页面上灵活操作。本任务针对窗口切换进行介绍。以人力资源综合服务系统为例，单击门户首页，在门户首页中单击“论坛”按钮，发现右侧多出一个窗口标签，如图所示。 image-20221026104123086 元素有属性，浏览器的窗口也有属性，浏览器窗口的属性可以用脚本(handle)来识别。对于初学者来说，可以将窗口切换分为四步进行：（1）获取第一个窗口的名字，代码为：print(driver.current_window_handle) （2）获取所有窗口的名字，代码为：print(driver.window_handles) （3）获取到第二个窗口的名字，代码为：print(driver.window_handles[1]) （4）进行窗口切换，代码为：driver.switch_to.window(driver.window_handles[1]) 12345678910111213141516171819202122232425262728293031实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码，单击“登录”按钮；（3）单击页面上面的“人资工作台”按钮；（4）单击页面左侧的“论坛后台管理”按钮；（5）单击“举报处理”按钮；（6）单击“回帖举报”按钮；（7）单击回帖举报页面中的“举报流水”按钮；（8）关闭新弹出的标签页。在PyCharm中进行代码编写：import timefrom selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮driver.find_element_by_link_text(&quot;论坛后台管理&quot;).click()#单击“论坛后台管理”按钮driver.find_element_by_link_text(&quot;举报处理&quot;).click()#单击“举报处理”按钮driver.find_element_by_link_text(&quot;回帖举报&quot;).click()#单击“回帖举报”按钮driver.find_element_by_xpath(&quot;/html/body/div[4]/div[2]/div/div[2]/div/div/div[2]/div[2]/table/tbody/tr[1]/td[10]/a[1]&quot;).click()#单击“举报流水”按钮print(driver.current_window_handle)# 获取第一个窗口的名字print(driver.window_handles)# 获取所有窗口的名字print(driver.window_handles[1])# 获取到第二个窗口的名字,Window_handle[1]用到数组的原理driver.switch_to.window(driver.window_handles[1])#进行窗口切换time.sleep(5)driver.close() 页面元素删除对于单击某个链接后是否弹出新窗口，可以通过图1和图2所示的HTML代码进行比较。通过观察两个窗口中页面HTML代码的区别，以及通过删除弹出新窗口中的某个属性后，再次单击弹出新窗口的超链接，得出的结论是有target属性就会弹出新的窗口。要想让链接不弹出新窗口，只需在代码执行时删除target属性即可。 image-20221026104226339 image-20221026104245875 target属性删除步骤（以人力资源综合服务系统门户首页中的论坛按钮为例）： （1）用Selenium定位“目标”链接：login_link=driver.find_element_by_XX(&quot;目标&quot;)； （2）删除已找到的页面元素的target属性：driver.execute_script(&quot;arguments[0].removeAttribute(&#39;target&#39;)&quot;,login_link)，其中arguments[0]的意思就是去字符串后面的第一个参数login_link的真正的值； （3）单击删除target属性后的页面元素：login_link.click() 12345678910111213141516171819202122232425262728293031实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码，单击“登录”按钮；（3）单击人力资源服务系统页面的“人资工作台”按钮；（4）在人资工作台页面单击左侧的“论坛后台管理”按钮；（5）单击“主题及回帖管理”按钮；（6）单击“回帖管理”按钮（要求不弹出新的标签页，在一个标签页中显示）。在PyCharm中进行代码编写：import timefrom selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮driver.find_element_by_link_text(&quot;论坛后台管理&quot;).click()#单击“论坛后台管理”按钮driver.find_element_by_link_text(&quot;主题及回帖管理&quot;).click()#单击“主题及回帖管理”按钮element=driver.find_element_by_xpath(&quot;/html/body/div[4]/div[2]/div/div[2]/div/div/div[2]/div[2]/table/tbody/tr[1]/td[10]/a[2]&quot;)#用selenium定位回帖管理链接信息driver.execute_script(&quot;arguments[0].removeAttribute(&#x27;target&#x27;)&quot;,element)#删除已找到的回帖管理页面元素的targer属性element.click()#单击删除targer属性后，进入回帖管理页面 image-20221027134238427 submit()方法使用 image-20221026104351337 1234567891011121314151617实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码；（3）单击“登录”按钮。在PyCharm中进行代码编写：import timefrom selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入到人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_id(&quot;loginBtn&quot;).submit()#单击“登录”按钮 操作下拉滚动条在Selenium中提供两种方法来处理拖动下拉滚动条的问题。 123451．通过连续按方向箭头的方法实现根据鼠标和键盘的相关知识和操作命令，可以借助于鼠标和键盘的操作命令来实现下拉滚动条的移动。例如，进入某个页面后存在下拉滚动条，且能够移动，则可以通过鼠标和键盘的操作命令找到隐藏的文字进行超链接，代码如下：ActionChains(driver).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).perform() 123452．用 JavaScript 中的语句实现滚动条移动JavaScript也是编写自动化脚本的一种语言，编写脚本的时候用得比较少，但是有的时候用JavaScript写的代码更加简单、实用。关于JavaScript的知识可以从网上进行简单学习。代码如下：driver.execute_script(&quot;window.scrollTo(0,0)&quot;)代码中的(0,0)代表页面横向和纵向的坐标。 比如，人力资源综合服务系统页面中的人资工作台页面左侧，需要进行拖动下拉条后才能看见页面最下面的文字，如图所示。 image-20221026104458800 123456789101112131415161718192021222324实例1：（1）进入人力资源综合服务系统登录页面；操作下拉滚动条方法（2）输入用户名和密码，单击“登录”按钮；（3）单击“人资工作台”按钮，进入人资工作台页面；（4）实现页面中滚动条的横向和纵向移动。在PyCharm中进行代码编写：from selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keysdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮ActionChains(driver).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ARROW_DOWN).perform()#滚动条移动 image-20221026104458800 123456789101112131415161718192021实例2：（1）进入人力资源综合服务系统登录页面；操作下拉滚动条方法（2）输入用户名和密码，单击“登录”按钮；（3）单击“人资工作台”按钮，进入人资工作台页面；（4）实现页面中滚动条的横向和纵向移动。在PyCharm中进行代码编写：from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮driver.execute_script(&quot;window.scrollTo(0,400)&quot;)#滚动条移动 下拉框处理对于图1图2所示问题，可以用三种方法进行元素定位。 image-20221026104728402 image-20221026104737793 使用选项元素标签定位实例1： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）单击人力资源服务系统页面中的“人资工作台”按钮； （4）单击人资工作台页面左侧的“员工基本信息管理”按钮； （5）单击“员工信息管理”按钮； （6）在员工信息管理页面选择政治面貌为其他。 在PyCharm中进行代码编写： 1234567891011121314151617181920212223242526import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮element=driver.find_element_by_link_text(&quot;员工基本信息管理&quot;)#定位“员工基本信息管理”按钮ActionChains(driver).click(element).perform()#单击“员工基本信息管理”按钮driver.find_element_by_link_text(&quot;员工信息管理&quot;).click()#单击“员工信息管理”按钮driver.find_elements_by_tag_name(&quot;select&quot;)[1].click()#单击select标签driver.find_elements_by_tag_name(&quot;option&quot;)[8].click()#选择政治面貌并单击 直接通过xpath层级标签定位实例2： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）单击人力资源服务系统页面中的“人资工作台”按钮； （4）单击人资工作台页面左侧的“员工基本信息管理”按钮； （5）单击“员工信息管理”按钮； （6）在员工信息管理页面选择政治面貌为其他。 在PyCharm中进行代码编写： 12345678910111213141516171819202122232425import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮element=driver.find_element_by_link_text(&quot;员工基本信息管理&quot;)#定位“员工基本信息管理”按钮ActionChains(driver).click(element).perform()#单击“员工基本信息管理”按钮driver.find_element_by_link_text(&quot;员工信息管理&quot;).click()#单击“员工信息管理”按钮driver.find_element_by_xpath(&quot;/html/body/div[4]/div[2]/div/div[2]/div[2]/div/div/form/div/div[1]/div/div[3]/select/option[6]&quot;).click()#选择政治面貌并单击 导入Select模块使用Select模块的方法除上面介绍的方法外，Selenium还提供了更高级的方法，即导入Select模块，直接根据属性或索引定位。（1）导入Select模块方法：from selenium.webdriver.support.select import Select;（2）通过select选项的名称定位选择对应选项，如选择其他选项，使用如下命令：select_by_visible_text(“其他”) 实例3： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）单击人力资源服务系统页面中的“人资工作台”按钮； （4）单击人资工作台页面左侧的“员工基本信息管理”按钮； （5）单击“员工信息管理”按钮； （6）在员工信息管理页面选择政治面貌为其他。 在PyCharm中进行代码编写： 12345678910111213141516171819202122232425import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.select import Selectdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮element=driver.find_element_by_link_text(&quot;员工基本信息管理&quot;)#定位“员工基本信息管理”按钮ActionChains(driver).click(element).perform()#单击“员工基本信息管理”按钮driver.find_element_by_link_text(&quot;员工信息管理&quot;).click()#单击“员工信息管理”按钮select=driver.find_element_by_id(&quot;dictPoliticalStatus&quot;)#定位下拉框Select(select).select_by_visible_text(&quot;其他&quot;)#定位下拉框选项 实例4： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）单击人力资源服务系统页面中的“人资工作台”按钮； （4）单击人资工作台页面左侧的“员工基本信息管理”按钮； （5）单击“员工信息管理”按钮； （6）在员工信息管理页面选择政治面貌为其他。 在PyCharm中进行代码编写： 12345678910111213141516171819202122232425import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.select import Selectdriver=webdriver.Chrome()driver.get(&quot;http://192.168.1.228/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮element=driver.find_element_by_link_text(&quot;员工基本信息管理&quot;)#定位“员工基本信息管理”按钮ActionChains(driver).click(element).perform()#单击“员工基本信息管理”按钮driver.find_element_by_link_text(&quot;员工信息管理&quot;).click()#单击“员工信息管理”按钮select=driver.find_element_by_id(&quot;dictPoliticalStatus&quot;)#定位下拉框Select(select).select_by_value(&quot;261&quot;)#定位下拉框选项 csdn查到的下拉框选项操作：Select 针对下拉框选项，可以直接获取下拉框中的值，然后再循环获取匹配，也可以直接通过元素定位直接操作。 **针对select&#x2F;option这样下拉选择框，如图展示： img ，我们可以直接使用webdriver中的*Select*类去处理 。 **首先是引入*Select*类(两种引包方法)： 12from selenium.webdriver.support.select import Selectfrom selenium.webdriver.support.ui import Select **ui.py文件中实际引入的也是 select下的**Select**类，所以我们引入ui包实际引入的还是*Select*类： img **源码中*Select*下有很多方法，专门用于处理下拉选择框操作： img options：返回属于该选择标签的所有选项列表 1234567891011from selenium import webdriverfrom selenium.webdriver.support.select import Selectfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&#x27;https://www.w3school.com.cn/tiy/t.asp?f=html_select&#x27;)driver.find_element_by_xpath(&quot;//a[contains(text(),&#x27;运行代码&#x27;)]&quot;).click()iframeResult = driver.find_element_by_xpath(&quot;//iframe[@id=&#x27;iframeResult&#x27;]&quot;)driver.switch_to.frame(iframeResult)result = Select(driver.find_element(By.CSS_SELECTOR, &quot;body:nth-child(2) &gt; select:nth-child(1)&quot;)).optionsfor i in result: print(i.text) 运行后的结果：下拉选择框中的数据循环打印显示在控制台 1234567F:\\virtualEnvironment\\venv\\Scripts\\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.pyVolvoSaabOpelAudiProcess finished with exit code 0 all_selected_options：返回属于此选择标签的所有选择的选项列表 1234result = Select(driver.find_element(By.CSS_SELECTOR, &quot;body:nth-child(2) &gt; select:nth-child(1)&quot;)).all_selected_optionsfor i in result: print(i.text)driver.quit() 运行后的结果：下拉选择框中循环打印被选中的的选项 1234F:\\virtualEnvironment\\venv\\Scripts\\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.pyVolvoProcess finished with exit code 0 first_selected_option：该选择标签中的第一个选择的选项（或正常选择中当前选择的选项） 123result = Select(driver.find_element(By.CSS_SELECTOR, &quot;body:nth-child(2) &gt; select:nth-child(1)&quot;)).first_selected_optionprint(result.text)driver.quit() 运行后的结果：打印下拉框中第一个被选中的的选项 1234F:\\virtualEnvironment\\venv\\Scripts\\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.pyVolvoProcess finished with exit code 0 下面示例html代码： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;select&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt;&lt;/body&gt;&lt;/html&gt; select_by_value：选择所有值都与参数匹配的选项。例如： select_by_value(“volvo”)，选择的就是第一个：” Volvo “ select_by_index：选择给定索引处的选项。这是通过检查元素的“索引”属性来完成的。例如：select_by_index(1)，选择的就是第二个：” Saab “ select_by_visible_text：选择所有显示与参数匹配的文本的选项。例如：图片标蓝框处的文本信息 img ，选择的就是第四个：” Audi “ 下面示例代码，仅供参考： 123456789101112result = Select(driver.find_element(By.CSS_SELECTOR, &quot;body:nth-child(2) &gt; select:nth-child(1)&quot;))result.select_by_index(1)for i in result.all_selected_options: print(i.text)result.select_by_value(&quot;opel&quot;)for i in result.all_selected_options: print(i.text)result.select_by_visible_text(&quot;Audi&quot;)for i in result.all_selected_options: print(i.text)time.sleep(10)driver.quit() 运行后的结果：每一个获到参数的方法全部都做了循环并打印到控制台 123456F:\\virtualEnvironment\\venv\\Scripts\\python.exe F:/git/AuomationTest/AuomationTestProject/webTestAuomation/selenium_select.pySaabOpelAudiProcess finished with exit code 0 deselect_all：清除所有选定的条目。这仅在SELECT支持多个选择时才有效。 deselect_by_value：取消选择所有值都与参数匹配的选项。 deselect_by_index：取消选择给定索引处的选项。 deselect_by_visible_text：取消选择所有显示与参数匹配的文本的选项。 1234567result = Select(driver.find_element(By.CSS_SELECTOR, &quot;body:nth-child(2) &gt; select:nth-child(1)&quot;))result.deselect_by_index(1)result.deselect_by_value(&quot;opel&quot;)result.deselect_by_visible_text(&quot;Audi&quot;)result.deselect_all()time.sleep(10)driver.quit() \\deselect_xxxxxxx\\开头的方法，就是取消选中操作的意思，如果没有指定值存在就会抛异常：NotImplementedError， 取消的方法其实就是跟选中的方法一样操作，无非就是先选中后再进行取消操作，在此就不再多作叙述，可自行实操下效果… 文件上传处理在实现UI自动化测试过程中，文件上传操作也是常见功能之一。对于文件上传功能并没有用到新方法或函数，关键是思路。上传过程一般要打开一个本地窗口，然后从窗口选择本地文件添加。在Selenium webdriver中文件上传并不复杂，只要定位“上传”按钮，找到input标签属性，如，然后通send_keys添加本地文件路径即可。 image-20221026105024607 image-20221026105057491 文件上传处理方法使用 实例： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）在人力资源服务系统页面单击“人资工作台”按钮； （4）在人资工作台页面单击左侧的“员工基本信息管理”按钮； （5）单击“员工照片管理”按钮； （6）在员工照片管理页面中单击“编辑”按钮，打开编辑页面； （7）在编辑页面中单击“选择本地文件”按钮，上传文件。 在PyCharm中进行代码编写： 12345678910111213141516171819202122232425import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;upp ercase&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;人资工作台&quot;).click()#单击“人资工作台”按钮a=driver.find_element_by_link_text(&quot;员工基本信息管理&quot;)#定位“员工基本信息管理”按钮ActionChains(driver).click(a).perform()#单击“员工基本信息管理”按钮driver.find_element_by_link_text(&quot;员工照片管理&quot;).click()#单击“员工照片管理”按钮driver.find_element_by_xpath(&quot;/html/body/div[4]/div[2]/div/div[2]/div/div/div/div[2]/table/tbody/tr[1]/td[9]/a&quot;).click()#单击“编辑”按钮driver.find_element_by_name(&quot;file&quot;).send_keys(r&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\juehua.jpg&quot;)#上传文件处理 页面截图操作截图方法：get_screenshot_as_file(self, filename)代码如下：driver.get_screenshot_as_file(r&quot;路径名\\图片名字&quot;) 实例： （1）进入人力资源综合服务系统登录页面； （2）对登录页面进行截图操作。 在PyCharm中进行代码编写： 123456from selenium import webdriverdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logo&quot;)#进入人力资源综合服务系统登录页面driver.get_screenshot_as_file(r&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\denglu.png&quot;)#截图操作 alert对话框处理当登录某些界面的时候，输入用户名和密码错误，会弹出一个alert（警告）对话框，如果不关闭该对话框就没法继续执行下去，所以无法通过定位的方式定位它的位置。弹出对话框主要分为三种类型：“警告对话框”“确认对话框”，“提示对话框”。 image-20221026105515248 1．警告对话框：警告对话框提供一个“确定”按钮让用户关闭该对话框，而且该对话框是模式对话框，也就是说，用户必须先关闭该对话框然后才能继续进行操作。2．确认对话框：确认对话框向用户提示一个“是与否”问题，用户可以根据单击“确定”按钮和“取消”按钮。3．提示对话框：提示对话框提供一个文本字段，用户可以在此字段输入一个答案来响应提示。有一个“确定”按钮和“取消”按钮。单击“确认”按钮会响应对应的提示信息，单击“取消”按钮会关闭对话框。Selenium提供switch_to_alert( )方法定位到alert&#x2F;confirm&#x2F;prompt对话框。使用text&#x2F;accept&#x2F;dismiss&#x2F;send_keys进行操作，需要注意的是send_keys只能对prompt操作，因为只有它是要输入内容的。text&#x2F;accept&#x2F;dismiss&#x2F;send_keys所代表的意思：● text( )#获取对话框文本值；● accept( )#相当于单击“确认”按钮；● dismiss( )#相当于单击“取消”按钮；● send_keys( )#输入值，这个alter和confirm没有输入对话框，所以这里不能用，只能用于prompt。 1234例如，接受对话框：element=driver.switch_to_alert()element.accept() 123例如，得到对话框的文本消息，比如得到“请输入用户名”。element=driver.switch_to_alert().textprint(element) 123例如，“取消”按钮：element=driver.switch_to_alert()element.dismiss() 123例如，输入值：element=driver.switch_to_alert()element.send_keys(&quot;hello&quot;) alert对话框处理方法使用 实例： （1）进入人力资源综合服务系统登录页面； （2）输入用户名和密码，单击“登录”按钮； （3）单击人力资源综合服务系统页面中的“门户首页”按钮； （4）单击门户首页中的“论坛”按钮（始终在一个标签页中运行）； （5）单击论坛首页中的某个热门主题信息； （6）单击热门主题信息页面中最下面的“回复”按钮； （7）打印弹出警告对话框中的文字信息，并关闭警告对话框。 在PyCharm中进行代码编写： 12345678910111213141516171819202122import timefrom selenium import webdriverfrom selenium.webdriver import ActionChainsdriver=webdriver.Chrome()driver.get(&quot;http://192.168.X.XXX/suthr/logo&quot;)#进入人力资源综合服务系统登录页面driver.implicitly_wait(30)driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码driver.find_element_by_class_name(&quot;btn-success&quot;).click()#单击“登录”按钮driver.find_element_by_link_text(&quot;门户首页&quot;).click()#单击“门户首页”按钮a=driver.find_element_by_xpath(&quot;/html/body/div[3]/div[1]/div/div/div/div[2]/div[2]/div/a&quot;)driver.execute_script(&quot;arguments[0].removeAttribute(&#x27;target&#x27;)&quot;,a)a.click()#单击“论坛”按钮driver.find_element_by_link_text(&quot;颠三倒四多&quot;).click()#单击热门主题信息driver.execute_script(&quot;window.scrollTo(0,2000)&quot;)b=driver.find_element_by_id(&quot;replyBtn&quot;)ActionChains(driver).click(b).perform()#弹出警告对话框time.sleep(5)element=driver.switch_to_alert().text#打印弹出警告对话框文字print(element)driver.switch_to_alert().accept()#关闭警告对话框 UnittestUnittest工作原理Unittest最核心的是TestCase、TestSuite、TestRunner、TestFixture四部分。 TestCase：用户自定义测试用例的基类，调用run( )方法时，会依次调用setUp( )方法、执行用例的方法、tearDown( )方法 TestSuite：测试用例集合，可以通过addTest( )方法手动增加TestCase，也可以通过TestLoader自动添加TestCase，TestLoader在添加用例时没有顺序 TestRunner：运行测试用例的驱动类，可以执行TestCase，也可以执行TestSuite，执行后TestCase和TestSuite会自动管理TestResult TestFixture：进行测试过程的准备活动，比如创建临时数据库、文件和目录等，其中setUp( )和setDown( )是最常用的方法 Unittest方法使用（1）写好TestCase：一个class继承unittest.TestCase，就是一个测试用例，其中有多个以test开头的方法，每个方法在load的时候会生成一个TestCase实例。如果一个class中有四个test开头的方法，则最后load到suite中时有四个测试用例。（2）由TestLoader加载TestCase到TestSuite。（3）由TextTestRunner运行TestSuite，运行结果保存在TextTestResult中。通过命令行或者unittest.main( )方法执行时，main会调用TextTestRunner中的run()方法来执行用例，或者可以直接通过TextTestRunner来执行用例。Runner执行时，默认将结果输出到控制台。可以设置其输出到文件，在文件中查看结果；也可以通过HTMLTestRunner将结果输出到HTML。 Unittest主要类关系正常调用Unittest的流程是TestLoader自动将测试用例TestCase中加载到TestSuite里，TextTestRunner调用TestSuite的run( )方法，顺序执行其中的TestCase中以test开头的方法，并得到测试结TestResult。 在执行TestCase过程中，先通过SetUp( )方法进行环境准备，执行测试代码，最后通过tearDown( )方法进行测试的还原。 TestLoader在加载过程中进行添加的TestCase是没有顺序的。一个TestCase里如果存在多个验证方法，会按照方法中test后方首字母的ASCII码从小到大排序后执行。 可以通过手动调用TestSuite的addTest( )、addTest( )方法来动态添加TestCase，这样既可以确定添加用例的执行顺序，也可避免TestCase中的验证方法一定要用test开头。 Unittest框架使用说明（1）import unittest #导入测试框架：定义一个继承自unittest.TestCase的测试用例类。定义setUp( )方法、tearDown( )方法、setUpClass( )方法、tearDownClass( )方法。其中setUp( )方法指在每个测试用例方法执行前都会执行一次；tearDown( )方法指在每次测试用例方法执行结束后都会执行一次；setUpClass( )方法指在一个测试用例集执行前只执行一次；tearDownClass( )方法指在一个测试用例集执行后只执行一次。（2）定义测试用例，名字以test开头：一个测试用例应该只测试一个方面，测试目的和测试内容应很明确。主要调用assertEqual( )、assertRaises( )等断言方法判断程序执行结果和预期值是否相符。（3）调用unittest.main( )方法启动测试：如果测试未通过，会输出相应的错误提示；如果测试全部通过，则不显示任何东西。 Unittest单元测试框架实例实例1： （1）分别定义四个方法：setUp( )、tearDown( )、test_denglu( )、test_denglu1( )； （2）使用setUp( )方法启动浏览器； （3）使用tearDown( )方法关闭浏览器； （4）使用test_denglu( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮； （5）使用test_denglu1( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮，在人力资源综合服务系统页面单击“门户首页”按钮。 在PyCharm中进行代码编写： 12345678910111213141516171819202122232425import unittest #引入unittestimport timefrom selenium import webdriverclass Denglu(unittest.TestCase): def setUp(self): #定义setUp()方法 self.driver=webdriver.Chrome() self.driver.implicitly_wait(30) def tearDown(self): #定义tearDown()方法 self.driver.quit() def test_denglu(self): #定义test_denglu()方法 self.driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;) self.driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;) self.driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;) self.driver.find_element_by_class_name(&quot;uppercase&quot;).click() time.sleep(5) def test_denglu1(self): #定义test_denglu1方法 self.driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;) #进入人力资源综合服务系统登录页面 self.driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;) #输入用户名 self.driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码 self.driver.find_element_by_class_name(&quot;uppercase&quot;).click() #单击“登录”按钮 self.driver.find_element_by_link_text(&quot;门户首页&quot;).click()#单击“门户首页”按钮 time.sleep(5)if __name__ == &#x27;__main__&#x27;: unittest.main()#调用unittest.main()方法启动测试 实例2： （1）分别定义四个方法：setUpClass( )、tearDownClass( )、test_denglu( )、test_denglu1( )； （2）使用setUpClass( )方法启动浏览器； （3）使用tearDownClass( )方法关闭浏览器； （4）使用test_denglu( )方法进入人力资源综合服务系统登录页面，输入账号和密码，单击“登录”按钮； （5）使用test_denglu1( )方法进入人力资源综合服务系统页面，在人力资源综合服务系统页面单击“门户首页”按钮。 在PyCharm中进行代码编写： 123456789101112131415161718192021222324import unittest #引入unittestimport timefrom selenium import webdriverclass Denglu(unittest.TestCase): @classmethod def setUpClass(cls): #定义setUpClass()方法 cls.driver=webdriver.Chrome() cls.driver.implicitly_wait(30) @classmethod def tearDownClass(cls): #定义tearDownClass()方法 cls.driver.quit() def test_denglu(cls): #定义test_denglu()方法 cls.driver.get(&quot;http://192.168.X.XXX/suthr/logon&quot;)#进入人力资源综合服务系统登录页面 cls.driver.find_element_by_name(&quot;username&quot;).send_keys(&quot;hrteacher&quot;)#输入用户名 cls.driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;123456&quot;)#输入密码 cls.driver.find_element_by_class_name(&quot;uppercase&quot;).click()#单击“登录”按钮 time.sleep(5) def test_denglu1(cls): #定义test_denglu1()方法 cls.driver.find_element_by_link_text(&quot;门户首页&quot;).click()#单击“门户首页”按钮 time.sleep(5)if __name__ == &#x27;__main__&#x27;: unittest.main()#调用unittest.main()方法启动测试 CSV文件读取1．前期工作：在某个文件中创建一个Excel文件，放入三行数据，这里是姓名+年龄（可以自己随意写），然后另存为CSV文件格式。2．读取步骤：（1）导入CSV代码库；（2）以只读形式打开文件；（3）由于打开文件的数据不能直接查看，所以要进行格式转换；（4）使用for循环打印除第一行标题之外的所有数据。 案例112345678910111213141516171819实例1import csvdef read(): path=r&quot;./csvread1.csv&quot; stream = open(path,&#x27;r&#x27;) data = csv.reader(stream) list = [] i =1 for row in data: if i != 0: list.append(row) i = i +1 return listif __name__ == &#x27;__main__&#x27;: data = read() for row in data: print(row)##################################################### 案例212345678910111213141516171819202122232425262728293031323334353637383940414243444546实例2import csvdef getcsv(): f = open(&quot;D:\\\\PythonProject\\\\项目自动化训练\\\\2022GZ\\PoTest\\\\Page\\\\data.csv&quot;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) L=[] i=0 data = csv.reader(f) for j in data: if i!=0: L.append(j) i=i+1 return Lprint(getcsv())# import csv## def getCsv():# with open(&quot;./data.csv&quot;, encoding=&quot;utf8&quot;) as f:# f = csv.reader(f)# f.__next__()# data =[]# for t in f:# data.append(t)# return data##################################################### @ddtclass Test(unittest.TestCase): def setUp(self) -&gt; None: self.lg = LoginPage() self.lg.login(&#x27;student&#x27;,&#x27;student&#x27;) @data(*csvv.getcsv()) @unpack def test_add(self,mingcheng,leibie): self.add = AddPage() self.add.add(mingcheng,leibie) time.sleep(2) def tearDown(self) -&gt; None: self.add.quit()if __name__ == &#x27;__main__&#x27;: unittest.main() 案例3123456789101112131415161718192021222324252627282930313233343536#读取csv文件def get_csv_file(line): # 文件路径需要自己修改成自己的文件路径 with open(r&quot;C:\\Users\\蒋英羽\\Desktop\\任务11.4：Web端—系统管理员 - 副本 (2)\\任务实训指导书答案及源码\\基于python\\源码\\Website\\test_data\\ccs.csv&quot;,encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index,row in enumerate(reader,1): if index==line: return rowif __name__ == &#x27;__main__&#x27;: data=get_csv_file(2) for row in data: print(row)#######################################################@ddt.ddtclass LoginTest(myunit.StartEnd): # @unittest.skip(&#x27;skip this case&#x27;) def test01_add_success(self): &#x27;&#x27;&#x27;操作成功&#x27;&#x27;&#x27; print(&quot;test case is start run...&quot;) test_date = function.get_csv_file(2) #创建参数接收测试数据 test_user_login(self.driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;) #登录 test_user_add(self.driver,test_date[0],test_date[1]) #输入测试数据 time.sleep(3) function.inser_img(self.driver,&quot;test01_add_null.png&quot;) # 截屏 po = UserAdd(self.driver) # 设置参数接收数据 self.assertIn(test_date[2], po.type_tjcg()) # 断言对比测试用例是否正确 print(&quot;test case is successful test end!&quot;) 数据驱动使用数据驱动模式，可以根据业务分解测试数据，只需定义变量，通过外部或者自定义的数据使其参数化，从而避免使用之前测试脚本中固定的数据。可以将测试脚本与测试数据分离，使得测试脚本在不同数据集合下高度复用。这不仅可以增加复杂条件场景的测试覆盖，还可以减少测试脚本的编写与维护工作。 1．环境准备：安装ddt代码库，打开cmd命令行窗口，输入pip install ddt命令在线安装。2．数据驱动步骤（1）在头部导入ddt代码库：import ddt；（2）在测试类前添加一个装饰器，表示这个类采用ddt代码库的方式实现数据驱动（@ddt.ddt）；（3）在测试方法前使用@ddt.data( )指定数据来源。3．代码编写思路：首先将测试数据单独存放，然后在编写脚本时调用存放的数据，逐条进行数据的读取。 实例：（1）进入人力资源综合服务系统登录页面；（2）输入用户名和密码，单击“登录”按钮；（3）单击人力资源综合服务系统页面左侧的“培训进修”按钮；（4）在培训进修页面中的培训内容输入框中输入多组数据进行查询。 1234567891011121314151617181920212223242526import unittestfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom potest10_26_01.csvread import readfrom ddt import ddt,data,unpack# import csvread@ddtclass ddt123(unittest.TestCase): def setUp(self): self.driver = webdriver.Chrome() self.driver.implicitly_wait(5) # @data(*read()) # @unpack stream = read() @data(*stream) @unpack def test1(self,lost,nlost2): self.driver.get(&quot;http://192.168.5.10/pams&quot;) self.driver.find_element(By.NAME, &quot;loginName&quot;).send_keys(lost) self.driver.find_element_by_name(&quot;password&quot;).send_keys(nlost2) self.driver.find_element(By.XPATH,&#x27;//*[@id=&quot;fmedit&quot;]/div[4]/button&#x27;).click() self.driver.find_element(By.PARTIAL_LINK_TEXT,&quot;资产报废&quot;).click() def tearDown(self): self.driver.quit()if __name__ == &#x27;__main__&#x27;: unittest.main() 总结python数据处理之 ddt，@data， @unpackpython 的unittest 没有自带数据驱动功能。 所以如果使用unittest，同时又想使用数据驱动，那么就可以使用DDT来完成。 DDT是 “Data-Driven Tests”的缩写，包含类的装饰器ddt和两个方法装饰器data（直接输入测试数据），file_data（可以从json或者yaml中获取测试数据） 【通常情况下，data中的数据按照一个参数传递给测试用例，如果data中含有多个数据，以元组，列表，字典等数据，需要自行在脚本中对数据进行分解或者使用unpack分解数据】 说明： @ddt 读取单个测试数据：—–装饰测试类，继承自TestCase的类 @data（）—装饰测试方法，拿到几个数据数据就执行几条用例（可以以“*变量”传入括号；也可以直接括号放入数值，逗号隔开） @data(a,b) ——那么a和b各运行一次用例 @data([a,d],[c,d]) —–如果没有unpack，那么[a,b]当成一个参数传入用例运行；如果有unpack，那么[a,b]被分解开，按照用例中的两个参数传递 @file_data(filename) —-对于json的文件，每一个json元素按照一个用例运行，可以依照python分解元组，列表或者字典的方式分解传入 @unpack —-解包，使用复杂的数据结构时，与此同时，测试方法的参数需要多个（参数的传值个数与解包后数量必须一一对应，“可以考虑用None”） 如果test_data的值很多（大于5）不建议使用unpack，可以考虑直接列表传出，索引取值（要注意参数不对等的情况） 【注意】使用请先导包 1.传列表 12import unittestfrom ddt import ddt,data,unpack unpack 的作用 12@unpack #在“脱外套”之后，针对你拿到的每一条数据根据逗号进行拆分def test_print_data(self,a,b): #需要按拆出来的每条数据内的个数进行传参 参数名要和字典中的key对应 12345678910111213141516import unittestfrom ddt import ddt,data,unpacktest_data=[&#123;&#x27;no&#x27;:1,&#x27;name&#x27;:&#x27;小李&#x27;&#125;,&#123;&#x27;no&#x27;:2,&#x27;name&#x27;:&#x27;小张&#x27;&#125;]@ddtclass TestMath(unittest.TestCase): def setUp(self): pass @data(*test_data) @unpack #在“脱外套”之后，针对你拿到的每一条数据根据逗号进行拆分 def test_print_data(self,a,b): #需要按拆出来的每条数据内的个数进行传参 print(a) print(b)#结果会报错，参数名需要与你的字典key对应 也可以不使用@package 返回的就是一个数组，直接填写list就是数组内容的拼接 list[0] 就是数组中的第一个元素 执行的时候一定要用main方法 数据断言断言使用的主要是assertEqual方法，如何检查测试用例执行是否正确：（1）通过比对页面元素的文本信息，检查测试用例执行结果的正确性，编写代码如下：Find_element().text（2）通过对比页面标题信息，检查测试用例执行结果的正确性，编写代码如下：Driver.title（3）通过对比网址信息，检查测试用例执行结果的正确性，编写代码如下：Driver.current_url（4）通过比对页面元素的属性信息，检查测试用例执行结果的正确性，编写代码如下：FindElement().get_attribute(&quot;value&quot;) 实例1： 1、进入人力资源综合服务系统登录页面； 2、输入用户名和密码，点击登录按钮； 3、在人力资源综合服务系统页面点击人资工作台按钮； 4、在人资工作台页面点击页面左侧的员工基本信息管理按钮； 5、点击员工信息管理按钮； 6、在员工信息管理页面点击录入员工按钮； 7、在录入员工页面对身份证号进行不输入信息和输入错误信息的数据驱动和断言代码编写，并进行异常错误处理和对异常错误进行截图。 测试数据，如图所示，在PyCharm中进行数据读取代码编写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import timefrom selenium import webdriverimport osimport unittestfrom ddt import ddt,data,unpackfrom selenium.webdriver import ActionChainsfrom potest10_26_01.csvread2 import read@ddtclass duanyan(unittest.TestCase): def setUp(self): self.driver=webdriver.Chrome() self.driver.implicitly_wait(5) def tearDown(self): self.driver.quit() @data(*read()) @unpack def test_denglu(self,sfz,dy): try: self.driver.get(&quot;http://192.168.5.7:12906/suthr&quot;) self.driver.find_element_by_id(&quot;username&quot;).send_keys(&#x27;hrteacher&#x27;) self.driver.find_element_by_id(&quot;password&quot;).send_keys(&#x27;123456&#x27;) self.driver.find_element_by_id(&quot;password&quot;).submit() self.driver.find_element_by_link_text(&quot;人资工作台&quot;).click() bz1 = self.driver.find_element_by_xpath(&#x27;/html/body/div[4]/div[1]/div/ul/li[5]/a/span[1]&#x27;) bz2 = self.driver.find_element_by_xpath(&#x27;/html/body/div[4]/div[1]/div/ul/li[5]/ul/li[1]/a/span[1]&#x27;) ActionChains(self.driver).move_to_element(bz1).perform() time.sleep(0.5) ActionChains(self.driver).click(bz2).perform() self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;pageContent&quot;]/div[2]/div[2]/div/div/div[1]/div/div/button&#x27;).click() self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;idCard&quot;]&#x27;).send_keys(sfz) self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;pageContent&quot;]/div[3]/div/div[1]/button&#x27;).click() sfze = self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;idCard-error&quot;]&#x27;).text self.assertEqual(sfze,dy) except: self.driver.execute_script(&quot;window.scrollTo(0,0)&quot;) time.sleep(2) # 方法 一 # self.driver.get_screenshot_as_file(&quot;./123/%s123_%s.png&quot;%(time.strftime(&#x27;%Y-%m-%d-%H-%M-%S&#x27;),&#x27;asdfasdfasdf&#x27;)) # 方法 二 cutime = time.strftime(&quot;%Y-%m-%d-%H-%M-%S&quot;) currenpath = os.path.dirname(__file__) path = currenpath+&quot;/456/&quot;+cutime+&#x27;.png&#x27; self.driver.get_screenshot_as_file(path) finally: self.driver.quit()if __name__ == &#x27;__main__&#x27;: unittest.main() 这两种方法都不能自己创建文件夹，需要自己自行创建 discover方法使用unittest进行测试的话，如果是需要实现上百个测试用例，把它们全部写在一个test.py文件中，文件会越来越臃肿，后期维护页麻烦。此时可以将这些用例按照测试功能进行拆分，分散到不同的测试文件中。这时候我们可以通过discover方法来执行所有的测试用例。 discover使用格式：discover(start_dir,pattern&#x3D;’test*.py’) 找到指定目录下所有测试模块，并可递归查到子目录下的测试模块，只有匹配到文件名才能被加载。如果启动的不是顶层目录，那么顶层目录必须单独指定。 start_dir：要测试的模块名或测试用例目录 pattern&#x3D;’test*.py’：表示用例文件名的匹配原则。此处匹配文件名以“test”开头的“.py”类型的文件，星号“*”表示任意多个字符 12345678import unittesttestdir = &quot;./discover&quot;discover=unittest.defaultTestLoader.discover(testdir,pattern=&quot;test*.py&quot;)if __name__ == &#x27;__main__&#x27;: unittest.TextTestRunner().run(discover) PageObject模式PO简介Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，主要是将每一个页面设计为一个Class，其中包含页面中需要测试的元素，这样在Selenium测试页面中可以通过调用页面类来获取页面元素，这样巧妙的避免了当页面元素id或者位置变化时，需要改测试页面代码的情况。 当页面元素id变化时，只需要更改测试页Class中页面的属性即可。 获取页面中元素的属性可以通过id，class或者XPath获取，在id唯一的情况下，可以使用id获取页面元素，否则可以使用XPath定位页面元素。 PO原理PageObject原理：将页面元素定位和对元素的操作行为封装成一个page类，实现对页面对象和测试用例的分离。一条测试用例可能需要多个步骤操作元素，将每个步骤单独的封装成一个方法，在执行测试用例的时候调用封装好的操作。 PO模式的作用PageObject模式的优点： （1）当某一个页面的元素发生变化，只需要修改该页面对象中的代码即可，不需要重复不断的修改测试用例。（2）提高代码重用性，结构更加清晰，维护代码更容易。（3）测试用例发生变化时，只需要修改少数页面对象即可。 案例：通过下面的案例步骤在Pycharm中进行代码编写 案例步骤： 1、进入人力资源综合服务系统登录页面； 2、输入用户名和密码； 3、点击登录按钮。 在PyCharm中项目目录如下： image-20221027154049469 (注：下划线的作用) 来自：Python中下划线的5种含义 - 知乎 (zhihu.com) img (注：*号的作用) 来自：Python3中* 和 ** 运算符的用法是什么-Python教程-PHP中文网 BasePage.py 123456789101112131415161718192021222324from time import sleep# 封装好的基础页面，所有页面都要继承class Page(): # 初始化数据 def __init__(self,driver): self.driver = driver self.base_url = &quot;http://192.168.5.7:12906&quot; # 写好对地址的一些中间操作 # 这里的作用就是： 后续继续添加页面直接在相应页面添加相应的后面的url就可以了 # 打开不同的页面，并对页面url进行断言 def _open(self,url): url_ = self.base_url+url print (&quot;This url is &quot; + url) self.driver.maximize_window() self.driver.get(url_) sleep(2) assert self.driver.current_url != url_ , &quot;did not lan on %s&quot;%url_ def open(self): self._open(self.url) def find_element(self,*loc): return self.driver.find_element(*loc) # 封装元素定位的方法 LoginPage.py 12345678910111213141516171819202122232425262728from selenium.webdriver.common.by import Byfrom page.BasePage import *class LoginPage(Page): # 在这里封装好 loginpage 需要用到的地址和定位 url = &#x27;/suthr/logon&#x27; username_loc = (By.NAME,&#x27;username&#x27;) password_loc = (By.NAME,&#x27;password&#x27;) submit_loc = (By.ID,&#x27;loginBtn&#x27;) # 在这边封装好定位需要用到的方法 def type_username(self,username): self.find_element(*self.username_loc).clear() self.find_element(*self.username_loc).send_keys(username) def type_password(self,password): self.find_element(*self.password_loc).clear() self.find_element(*self.password_loc).send_keys(password) def type_submit(self): self.find_element(*self.submit_loc).click() # 在这边实例化整个对象，并封装成一个方法def user_login(driver,username,password): login_page=LoginPage(driver) login_page.open() login_page.type_username(username) login_page.type_password(password) login_page.type_submit() test_login.py 12345678import timefrom selenium import webdriverfrom page.LoginPage import *driver = webdriver.Chrome()user_login(driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;)time.sleep(3)driver.quit() 最后题目 image-20221027212316786 driver.py1234567from selenium import webdriverdef browser(): driver=webdriver.Chrome() #打开谷歌浏览器 return driver function.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osimport smtplibfrom email.mime.text import MIMETextfrom email.header import Headerimport csv#截图方法def inser_img(driver,filename): #获取当前模块所在路径 func_path=os.path.dirname(__file__) #获取test_case目录 base_dir=os.path.dirname(func_path) #将路径转化为字符串 base_dir=str(base_dir) #对路径的字符串进行替换 base_dir=base_dir.replace(&#x27;\\\\&#x27;,&#x27;/&#x27;) #获取项目文件的根目录路径 base=base_dir.split(&#x27;/Website&#x27;)[0] #指定截图存放路径 filepath=base+&#x27;/Website/test_report/screenshot/&#x27;+filename driver.get_screenshot_as_file(filepath)#查找最新的测试报告def latest_report(report_dir): lists = os.listdir(report_dir) lists.sort(key=lambda fn: os.path.getatime(report_dir + &#x27;\\\\&#x27; + fn)) file = os.path.join(report_dir, lists[-1]) return file#将测试报告发送到邮件def send_mail(latest_report): #这里所有的参数使用的是163邮箱，如果使用别的邮箱需要自己配置参数 f=open(latest_report,&#x27;rb&#x27;) mail_content=f.read() f.close() smtpserver = &#x27;smtp.163.com&#x27; user = &#x27;XXX@163.com&#x27; #填入自己的邮箱账号 password = &#x27;UCSLGPTXXXMFAX&#x27; #填入自己的授权码，注意非邮件密码 sender = &#x27;XXX@163.com&#x27; #填入发送邮箱的账号 receives = &#x27;XXX@qq.com&#x27; #填入接收邮箱的账号 subject = &#x27;Selenium自动化测试报告&#x27; msg = MIMEText(mail_content, &#x27;html&#x27;, &#x27;utf-8&#x27;) msg[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) msg[&#x27;From&#x27;] = sender msg[&#x27;To&#x27;] = receives smtp = smtplib.SMTP_SSL(smtpserver, 465) smtp.helo(smtpserver) smtp.ehlo(smtpserver) smtp.login(user, password) print(&quot;Start send email...&quot;) smtp.sendmail(sender, receives, msg.as_string()) smtp.quit() print(&quot;Send email end!&quot;)#读取csv文件def get_csv_file(line): # 文件路径需要自己修改成自己的文件路径 with open(r&quot;C:\\Users\\蒋英羽\\Desktop\\任务11.4：Web端—系统管理员 - 副本 (2)\\任务实训指导书答案及源码\\基于python\\源码\\Website\\test_data\\ccs.csv&quot;,encoding=&#x27;utf-8-sig&#x27;) as file: reader=csv.reader(file) for index,row in enumerate(reader,1): if index==line: return rowif __name__ == &#x27;__main__&#x27;: data=get_csv_file(2) for row in data: print(row) myunit.py1234567891011import unittestfrom driver.driver import *class StartEnd(unittest.TestCase): def setUp(self): self.driver=browser() self.driver.implicitly_wait(10) self.driver.maximize_window() def tearDown(self): self.driver.quit() AddPage.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from selenium.webdriver.common.by import Byfrom Website.test_case.page_object.BasePage import *from time import sleepclass UserAdd(Page): url=&#x27;/&#x27; Rzgzt_loc=(By.LINK_TEXT,&#x27;人资工作台&#x27;) #定位人资工作台按钮 Mhhtgl_loc=(By.LINK_TEXT,&#x27;门户后台管理&#x27;) #定位门户后台管理按钮 Yqljgl_loc=(By.XPATH,&#x27;/html/body/div[4]/div[1]/div/ul/li[16]/ul/li[4]/a&#x27;) #定位友情链接管理按钮 Tjlj_loc=(By.XPATH,&#x27;//*[@id=&quot;searchForm&quot;]/div/button[2]&#x27;) #定位添加链接按钮 Ljmc_loc=(By.ID,&#x27;title&#x27;) #定位链接名称输入框 Ljdz_loc=(By.ID,&#x27;url&#x27;) #定位链接地址输入框 Bcan_loc=(By.XPATH,&#x27;//*[@id=&quot;ajax-modal&quot;]/div[3]/button[1]&#x27;) #定位保存按钮 Tsxx_loc=(By.ID,&#x27;title-error&#x27;) #定位连接名称提示消息 Tsxxdz_loc=(By.ID,&#x27;url-error&#x27;) #定位连接地址提示消息 Tstc_loc=(By.CLASS_NAME,&#x27;bootbox-body&#x27;) #定位弹窗提示文字信息 Tjcg_loc=(By.XPATH,&#x27;//*[@id=&quot;pageContent&quot;]/div[2]/div/div/div/div[2]/table/tbody/tr/td[2]&#x27;) #添加成功文本 def type_Rzgzt(self): self.find_element(*self.Rzgzt_loc).click() #点击人资工作台按钮 def type_Mhhtgl(self): self.find_element(*self.Mhhtgl_loc).click() #点击门户后台管理按钮 def type_Yqljgl(self): self.find_element(*self.Yqljgl_loc).click() #点击友情链接管理按钮 def type_Tjlj(self): self.find_element(*self.Tjlj_loc).click() #点击添加链接按钮 def type_Ljmc(self,Name): self.find_element(*self.Ljmc_loc).clear() self.find_element(*self.Ljmc_loc).send_keys(Name) #输入链接名称 def type_Ljdz(self,dizhi): self.find_element(*self.Ljdz_loc).clear() self.find_element(*self.Ljdz_loc).send_keys(dizhi) #输入链接地址 def type_Bcan(self): self.find_element(*self.Bcan_loc).click() # 点击保存按钮 def type_Tsxx(self): return self.find_element(*self.Tsxx_loc).text # 获取连接名称提示信息 def type_Tsxxdz(self): return self.find_element(*self.Tsxxdz_loc).text # 获取连接地址提示信息 def type_Tstc(self): return self.find_element(*self.Tstc_loc).get_attribute(&quot;innerHTML&quot;) # 读取弹窗文字信息 def type_tjcg(self): return self.find_element(*self.Tjcg_loc).text # 获取添加成功文本 def type_gd(self): return self.driver.execute_script(&#x27;window.scrollBy(0,1000)&#x27;)def test_user_add(driver,Name,dizhi): add_page=UserAdd(driver) add_page.type_Rzgzt() sleep(1) add_page.type_gd() add_page.type_Mhhtgl() sleep(3) add_page.type_Yqljgl() sleep(1) add_page.type_Tjlj() sleep(1) add_page.type_Ljmc(Name) sleep(1) add_page.type_Ljdz(dizhi) sleep(1) add_page.type_Bcan() #封装添加功能 BasePage.py1234567891011121314151617181920212223242526from time import sleepclass Page(): &quot;&quot;&quot;基础类，用于所以页面对象类继承&quot;&quot;&quot; def __init__(self, driver): self.driver = driver self.base_url = &#x27;http://192.168.16.156/suthr/logon&#x27; self.timeout = 10 def _open(self, url): url_ = self.base_url + url print(&quot;Test page is %s&quot; % url_) self.driver.maximize_window() self.driver.get(url_) sleep(2) assert self.driver.current_url == url_, &#x27;Did not land on %s&#x27; % url_ def open(self): self._open(self.url) def find_element(self, *loc): return self.driver.find_element(*loc) LoginPage.py123456789101112131415161718192021222324252627282930313233343536from Website.test_case.page_object.BasePage import *from selenium.webdriver.common.by import Byclass LoginPage(Page): url=&#x27;/&#x27; username_loc=(By.NAME,&#x27;username&#x27;) #定位用户名输入框 password_loc=(By.NAME,&#x27;password&#x27;) #定位密码输入框 submit_loc=(By.ID,&#x27;loginBtn&#x27;) #定位登录按钮 def type_username(self,username): self.find_element(*self.username_loc).clear() self.find_element(*self.username_loc).send_keys(username) #输入用户名 def type_password(self,password): self.find_element(*self.password_loc).clear() self.find_element(*self.password_loc).send_keys(password) # 输入密码 def type_submit(self): self.find_element(*self.submit_loc).click() #点击登录按钮def test_user_login(driver,username,password): login_page=LoginPage(driver) login_page.open() login_page.type_username(username) login_page.type_password(password) login_page.type_submit() #封装登录功能 test_add.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import unittestfrom Website.test_case.model import function,myunitfrom Website.test_case.page_object.LoginPage import *from Website.test_case.page_object.AddPage import *import timeimport ddt@ddt.ddtclass LoginTest(myunit.StartEnd): # @unittest.skip(&#x27;skip this case&#x27;) def test01_add_success(self): &#x27;&#x27;&#x27;操作成功&#x27;&#x27;&#x27; print(&quot;test case is start run...&quot;) test_date = function.get_csv_file(2) #创建参数接收测试数据 test_user_login(self.driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;) #登录 test_user_add(self.driver,test_date[0],test_date[1]) #输入测试数据 time.sleep(3) function.inser_img(self.driver,&quot;test01_add_null.png&quot;) # 截屏 po = UserAdd(self.driver) # 设置参数接收数据 self.assertIn(test_date[2], po.type_tjcg()) # 断言对比测试用例是否正确 print(&quot;test case is successful test end!&quot;) def test02_add_null(self): &#x27;&#x27;&#x27;连接名称为空&#x27;&#x27;&#x27; print(&quot;test case is start run...&quot;) test_date = function.get_csv_file(3) #创建参数接收测试数据 test_user_login(self.driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;) #登录 test_user_add(self.driver,test_date[0],test_date[1]) #输入测试数据 time.sleep(3) function.inser_img(self.driver,&quot;test01_add_null.png&quot;) # 截屏 po = UserAdd(self.driver) # 设置参数接收数据 self.assertIn(test_date[2], po.type_Tsxx()) # 断言对比测试用例是否正确 print(&quot;test case is successful test end!&quot;) def test03_add_null(self): &#x27;&#x27;&#x27;连接地址为空&#x27;&#x27;&#x27; print(&quot;test case is start run...&quot;) test_date = function.get_csv_file(4) #创建参数接收测试数据 test_user_login(self.driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;) #登录 test_user_add(self.driver,test_date[0],test_date[1]) #输入测试数据 time.sleep(3) function.inser_img(self.driver,&quot;test01_add_null.png&quot;) # 截屏 po = UserAdd(self.driver) # 设置参数接收数据 self.assertIn(test_date[2], po.type_Tsxxdz()) # 断言对比测试用例是否正确 print(&quot;test case is successful test end!&quot;) def test04_add_repeat(self): &#x27;&#x27;&#x27;连接名称重复&#x27;&#x27;&#x27; print(&quot;test case is start run...&quot;) test_date = function.get_csv_file(5) #创建参数接收测试数据 test_user_login(self.driver,&#x27;hrteacher&#x27;,&#x27;123456&#x27;) #登录 test_user_add(self.driver,test_date[0],test_date[1]) #输入测试数据 time.sleep(3) function.inser_img(self.driver,&quot;test01_add_null.png&quot;) # 截屏 po = UserAdd(self.driver) # 设置参数接收数据 self.assertIn(test_date[2], po.type_Tstc()) # 断言对比测试用例是否正确 print(&quot;test case is successful test end!&quot;) ccs.csv12345测试数据测试连接,www.ceshi.com,测试连接,www.ceshi.com,必须填写测试链接,,必须填写测试连接,www.ceshi.com,链接名称已经存在，请重新填写！ runtest.py123456789101112131415161718192021222324252627import unittestfrom Website.test_case.model.function import *from HTMLTestRunner import HTMLTestRunnerimport timereport_dir=&#x27;./test_report&#x27;test_dir=&#x27;./test_case&#x27;print(&quot;start run test case&quot;)discover=unittest.defaultTestLoader.discover(test_dir,pattern=&quot;test_add.py&quot;)now=time.strftime(&quot;%Y-%m-%d %H_%M_%S&quot;)report_name=report_dir+&#x27;/&#x27;+now+&#x27;result.html&#x27;print(&quot;start write report..&quot;)with open(report_name,&#x27;wb&#x27;) as f: runner=HTMLTestRunner(stream=f,title=&quot;Test Report&quot; ,description=&quot;localhost login test&quot;) runner.run(discover) f.close()print(&quot;find latest report&quot;)latest_report=latest_report(report_dir)print(&quot;send email report..&quot;)send_mail(latest_report)print(&quot;Test end&quot;) 自己跟着敲的 image-20221028102848155 image-20221028102955027 os出来的路径就是”&#x2F;“ 无需字符串转化 也不用base_dir=base_dir.replace(&#39;\\\\&#39;,&#39;/&#39;)转换 for index,row in enumerate(reader,1):是什么意思 总而言之enumerate就是枚举的意思，把元素一个个列举出来，第一个是什么，第二个是什么，所以他返回的是元素以及对应的索引。 1234567891011121314151617181920212223line = [1,2,3,4,5,6,7,8,9]for i,j in enumerate(line): print(i,j)#以下是输出结果0 11 22 33 44 55 66 77 88 9#eg2:line = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]for i,j in enumerate(line): print(i,j)#output:0 a1 b2 c3 d4 e","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"软件测试/自动化测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"性能测试-jmeter","slug":"软件测试/性能测试-jmeter","date":"2022-10-18T05:34:26.000Z","updated":"2022-11-01T13:50:55.717Z","comments":true,"path":"2022/10/18/软件测试/性能测试-jmeter/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-jmeter/","excerpt":"","text":"2022年10月19日 更 线程操作系统进行运算调度的最小单位 一条进程中可以有多条线程，共享进程中的全部系统资源 每个用户作为一个线程，减少资源浪费 性能测试指标 传输协议https &#x3D; http+ssl&#x2F;tls(一种加密手段) HTTPS的默认端口为443 http为80 HTTP-统一资原标识符(URL) http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 协议部分代表网页便用的是HTTP协议。在Interneti中可以使用多种协议，如HTTP,FTP等等。在”HTTP”后面的“I为分隔符 域名部分“www.aspxfans.com&quot;。一个URL中，也可以便使用IP地址作为域名使用 端口部分跟在域名后面的是端口，域名和端口之间使用“：”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80/tcp 虚拟目录部分从域名后的第一个“”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;“ 文件名部分从域名后的最后一个“&#x2F;”开始到”？”为止，是文件名部分，如果没有”？”，则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是”index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 锚部分从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分（可以理解为定位） 参数部分从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 http请求数据包 image-20221019100411030 请求头 -20221019100852406 响应数据包 image-20221019101127937 Jmeter常见术语 image-20221019101615572 jmeter 运行原理 image-20221019101727280 jmeter 目录结构 image-20221019101902521 image-20221019101937467 image-20221019102109365 Jmeter测试元件 jmeter的工作区 image-20221019105232197 区域①是一个目录树，存放测试设计过程中使用到的元件；执行过程中默认从根节点开始顺序遍历树上的元件。 区域②是测试计划编辑区域，在”用户定义的变量”区域，我们可以定义整个测试计划公用的全局变量，这些变量对多个线程组有效。我们还可以对线程组的运行进行设置：比如”独立运行每个线程组”、“Run tearDown Thread Groups after shutdown of main threads” 测试计划：是JMeter测试脚本根节点，每一个测试脚本都是一个测试计划。 名称：可以随意设置，最好有业务意义。 注释：可以随意设置，可以为空。 用户定义的变量：全局变量 独立运行每个线程组：如果一个测试计划中有多个线程组，设置此项可以生效。不设置时每个线程组同时运行。 Run tearDown Thread Groups after shutdown of main threads:关闭主线程后运行tearDown程序来正常关闭线程组（运行的线程本次迭代完成后关闭）。 函数测试模式：在调试脚本的过程中，如果需要获取服务器返回的详细信息就可以选择此项：选择此项后，如果记录较多的数据会影响测试效率，所以在执行性能测试时，最好关闭此项。 Add directory or jar to classpath:把测试需要依赖的jar包或包所在的目录加入类路径。测试需要依赖的jar包还可以直接放到%JMETER HOME%Iib目录下。(%JMETER HOME%:JMeter安装目录 区域③是菜单栏，图标是菜单快捷方式。 jmeter作用域规则 除了逻辑控制器，其他配置元件遵循分层规则 父采样器 仅对父生效 父逻辑控制器 对逻辑控制器下采样器生效 jmeter执行顺序 0、 配置元件(Config Element) 1、前置处理器(Pre Processors) 2、定时器(Timer) 3、取样器(Sampler) 4、后置处理器(Post Processors) 5、断言(Assertions) 6、监听器(Listener) 注意，只有取样器结果不为空的情况下才会执行4、5、6 一个简单的例子： img](v2-8c717db24ab9258895cf8fe083cb4c68_1440w.jpg)![img jmeter脚本添加 根节点测试计划&#x3D;场景 测试计划中至少需要线程组 &#x3D; group 取样器 模拟用户请求 监听器 衡量系统性能 添加http请求 方法：HTTP清求的方法，最常用的有GET和POST。 路径：除去主机地址部分的访问链接。 Content encoding:字符编码格式，默认iso8859,大多数应用会指定成UTF-8格式。 自动重定向：HttpClient接收到请求后，如果请求中包含重定向请求，HttpClient是可以自动跳转的，但是只针对GET与HEAD请求，勾选此项则“跟随重定向”失效：自动重定向可以自动转向到最终目标页面，但是JMeter是不记录重定向过程内容的，比如在查看结果树中是无O法找到重定向过程内容的(A重定向到B,此时只记录B的内容不记录A的内容，A的响应内容暂且叫做过程内容)，如果此时要做关联，那就比较遗憾了，无法关联到。 image-20221019112922675 返回的状态码为 302 并且跟随一个 链接，自动请求 然后跳转 302便是过程 跟随重定向：HTTP请求的默认选项，当响应Code是3xx时（比如301是重定向），自动跳转到目标地址。与自动重定向不同，JMeter会记录重定向过程中的所有请求响应，在查看结果树时可以看到服务器返回的内容，所以可以对响应的内容做关联。 Use KeepAlive:对应HTTP响应头中的Connection:Keep-Alive,默认选中。 Use multipart&#x2F;form-data for POST:当发送HTTP POST请求时，使用Use multipart&#x2F;form-data方法发送，比如我们可以用它做文件上传：这个属性是与方法POST绑定的。（提交文件时需要用到） Browser-compatible headers:浏览器兼容模式，如果使用Use multipart&#x2F;form-data for POST建议勾选此项。 Parameters:同请求一起发送的参数，可以把要发送的参数（就是表单域）与值填到此域GET方法也适用 Body Data：指的是实体数据，就是请求报文里面主体实体的内容，一般向服务器发送请求携带的实体主体参数，可以写入这里。Parameters和Body Data只能同时使用其中一种方式。 Files Upload:当使用Use multipart&#x2F;.form-data for POST时可以在此一同上传文件。MIME类型有STRICT、BROWSER COMPATIBLE、RFC6532等. 添加查看结果树 可以查看每次请求的服务器返回信息，运行时耗费资源，在性能测试的时候通常用于调试，运行时会关闭 为取样器添加content—type（消息体数据）采用body形式添加取样器的时候需要在取样器下面添加配置元件 信息头管理器，将content-type添加进去 请求中有添加附件 image-20221019144016498 image-20221019151506742 image-20221019144432892 添加思考时间请求之间的思考间隔 image-20221019154358403 添加检查点 Apply to main（父）sub（子） 看查找内容的需求 响应字段 模式匹配规则 包括（支持） 匹配-完全匹配-不敏感-支持 相等-完全相等-敏感-不支持 字符串-在响应中能找到即可-敏感-不支持 否-取反 或者-多个模式有一个为成功就是成功 添加事务性能测试的核心，一系列的操作 image-20221019171505731 第一个选项，会把登录事务看做成一个采样器输出在查看结果树中 第二个选择，把时间等待和前置处理器的时间也算上 添加集合点用于模拟很多人一起提交的场景 image-20221019172851546 模拟用户组的数量：一次性释放的线程数，为0时&#x3D;线程组的线程数 超时时间：设置等待的时间，0&#x3D;一致等待 注意，若设置的用户组数量&gt;当前线程数，等待时间为0会一直等待下去 在子中天啊及 设置脚本参数化jmeter csv数据文件设置属于 配置元件 使用csv数据文件${变量名称} image-20221019175257266 查看参数取值情况在查看结果树前，添加调试取样器 jmeter函数 CSVREAD image-20221019180134384 应该严格区分大小写 *alias特性可打开同一个文件 每个线程读取的行数都不同，除非线程数大于行数 使用scvread.delimiter可以切换分隔符 CSV file to get values from|*alias: CSV文件取值路径，这里填写需要参数化的参数的文件路径。 CSV文件列号引next|*aias: 文件起始列号：CSV文件列号是从0开始的，第一列为0，第二列为1，依次类推。 注意: 调试取样器中看不到函数的值，只能看到变量的值 jmetee 函数，__Random image-20221022142656318 返回指定最大值和最小值之间的随机数 image-20221022142012439 image-20221022142048244 jmeter函数——time函数 image-20221022142151372 image-20221022142257852 image-20221022142332518 jmeter 上传文件参数化上床文件参数化 把参数的名称改成 csv文件的内容，和参数化同样步骤 要保证，文件路径下有文件 上传的文件为0大小，一个功能缺陷 到此总结一下脚本编辑用到的功能点 还差一个 关联 jmeter关联使用场景 image-20221022143357923 正则表达式提取器 image-20221022145156112 image-20221022145239719 会作用于所有平级的采样器 添加到子中，作用域父 image-20221022145806852 image-20221022150905827 image-20221022150923150 image-20221022151624469 image-20221022151912441 image-20221022151959229 image-20221022152107829 image-20221022152209041 正则表达式规则 image-20221022152310450 image-20221022152337793 1、相关理论https://zhuanlan.zhihu.com/p/27999878 场景：B测试需要使用A接口返回的数据，故需要对A接口的响应报文进行后置处理，如下 img 1、添加Jmeter正则表达式提取器：在具体的Request下添加Jmeter正则表达式提取器（Jmeter正则表达式在“后置处理器”下面） 2、Jmeter正则表达式提取器控制面板，截图如下： img 位置1：名称及注释 位置2：正则表达式提取内容的范围。（关于各字段的详细说明请查阅协议的相关说明 位置3：正则表达式提取的相关设置 引用名称：其他地方引用提取值的变量名称，如填写的是：str，具体的引用方式是${str} 正则表达式：提取内容的正则表达式【稍注意一下：()表示提取，对于你要提前的内容需要用小括号括起来】 模板：用$$引用起来，如果在正则表达式中有多个提取表达式（多个括号括起来的东东），则可以是$1$，$2$等等，表示解析到的第几个值给str，正则表达式的提取模式，值从1开始， 匹配数字(0代表随机)：0代表随机，-1代表所有，其余正整数代表将在已提取的内容中，第几个匹配的内容。 缺省值：正则匹配失败时，取的值 关于正则表达式多说一点： 1、在使用正则表达式提取器的过程中，如果匹配数字择的是-1，还可以通过${str_1}的方式来取第1个匹配的内容，${str_2}来取第2个匹配的内容。 2、关于正则和?是不一样的，在上述的例子中使用正则(.?)或者正则(.)都是可行的。这个是正则中的贪婪与非贪婪模式。 一个符合要求的正则表达式：name &#x3D; “file” value &#x3D; “(.+?)”&gt;。 ()：封装了待返回的匹配字符串。 .：匹配任何字符串。 +：一次或多次。 ?：不要太贪婪，在找到第一个匹配项后停止 ————————-2021-04-29-更新下———————– 我再更新下，用案例去说明下匹配规则： 以下是response的返回，可以看到有三个packageId 123456789101112131415161718192021&#123; &quot;code&quot;:0, &quot;data&quot;:&#123; &quot;serviceInfos&quot;:[ &#123; &quot;packageId&quot;:&quot;1676176670240829445&quot;, &quot;packageType&quot;:&quot;0&quot;, &#125;, &#123; &quot;packageId&quot;:&quot;1674316942942433281&quot;, &quot;packageType&quot;:&quot;1&quot;, &#125;, &#123; &quot;packageId&quot;:&quot;1674317078124851204&quot;, &quot;packageType&quot;:&quot;13&quot;, &#125; ], &#125;, 获取第1个packageId-&gt;1676176670240829445 img 获取第一个packageId完整信息-&gt;“packageId”:”1676176670240829445” img 获取第2个packageId img 获取第3个packageId img 获取所有packageId，自由模式{$变量_序号} img 测试结果： 1234567 模板配置$1$ 匹配数字1:$&#123;packageId1&#125; 模板配置$0$ 匹配数字1:$&#123;packageId2&#125; 模板配置$1$ 匹配数字2:$&#123;packageId5&#125; 模板配置$1$ 匹配数字3:$&#123;packageId6&#125; 模板配置$1$ 匹配数字1,自由输出：变量_1=$&#123;packageId_1&#125; 变量_2=$&#123;packageId_2&#125; 变量_3=$&#123;packageId_3&#125; 对应结果如下： img 总结： 1.$1$和$0$ 区别就是要不要匹配头完整传出来； 2.如果你想获取报文中的第N个字段，有两种方法： 一种使用匹配数字1-N控制， 一种是匹配数字 -1全部返回，变量_序号的模式可以自由选择你需要的第几个数。 教学中用 匹配数字0 然后在查看结果树中查看 可以调用的参数 边界提取器 image-20221022155957795 image-20221022155942667 匹配出多个 image-20221022160151787 image-20221022160207342 总结一下 出错了，还是用正则表达式提取器 调试取样器中查看参数的名称 image-20221022172110871 文档名称的斜杠正反无所谓 填写文件参数化的时候忘记带后缀了 控制器循环控制器 image-20221022161605838 image-20221022161537965 image-20221022161951155 交替控制器 image-20221022162044622 image-20221022162518184 image-20221022162702996 jmeter控制器详解https://www.cnblogs.com/keenajiao/p/15769679.html 仅一次控制器 image-20221022163023169 随机控制器 image-20221022163043095 运行控制器 image-20221022163114872 简单控制器 image-20221022163137444 image-20221022163215947 吞吐量控制器 image-20221022163235761 image-20221022163332548 将脚本放到场景中运行jmeter线程组 image-20221022200153912 image-20221022205424247 image-20221022205928949 image-20221022205955403 image-20221022210307841 image-20221022211326137 image-20221022211342170 image-20221022211727764 安装插件，放在apache-jmeter-5.4.1\\lib\\ext目录下，之后操作不会了 场景设置场景设置在jmeter 的 GUI中设置 image-20221022212744794 场景运行本地GUI运行 image-20221022212940051 image-20221022212914710 远程GUI运行 image-20221022213058709 image-20221023114604007 非GUI运行 image-20221023114656607 image-20221023121611696 远程运行 image-20221023122331297 监听器 image-20221023161043384 图形结果 image-20221023161222409 image-20221023161237270 image-20221023161304844 image-20221023161328531 image-20221023161949630 image-20221023161925569 image-20221023162014786 image-20221023162051449 image-20221023162119235 image-20221023184818425 image-20221023184828763 image-20221023184836683 image-20221023184847857 image-20221023184900903 image-20221023184909669 image-20221023184918137 image-20221023184936676 image-20221023184943922 非GUI运行时各个参数的意思 image-20221023194215241 避免程序运行到一半卡住然后运行不出来的问题 需要把.jtl文件生成测试报告 测试报告文件中的意思 image-20221023194815114 image-20221023194726817 image-20221023194752495 总结： 运行的时候 一定要注意设置好线程 文件上传的路径要用斜杠“&#x2F;” csv文件设置要用反斜杠“\\” Fiddler恢复默认设置布局1.启动fiddler时，按住shift不放，弹出确认恢复默认设置的弹窗，点击是即可 img 阻塞线程，直到线程被阻塞到多少个后，一起释放 2022年11月1日 更新脚本录制方法","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"软件测试/性能测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"性能测试","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"jmeter","slug":"jmeter","permalink":"http://example.com/tags/jmeter/"}]},{"title":"java环境变量配置","slug":"软件测试/java环境变量配置","date":"2022-10-18T04:53:44.000Z","updated":"2022-10-18T04:57:17.269Z","comments":true,"path":"2022/10/18/软件测试/java环境变量配置/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配置不好CLASSPATH也会找不到java命令 14之后的只需要弄.;%JAVA_HOME%lib 就可以了","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"软件测试导图","slug":"map/软件测试_map","date":"2022-10-18T03:01:48.000Z","updated":"2022-10-25T11:20:53.656Z","comments":true,"path":"2022/10/18/map/软件测试_map/","link":"","permalink":"http://example.com/2022/10/18/map/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95_map/","excerpt":"","text":"","categories":[{"name":"map","slug":"map","permalink":"http://example.com/categories/map/"}],"tags":[{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}]},{"title":"在HEXO中插入思维导图","slug":"hexo/在HEXO中插入思维导图","date":"2022-10-18T02:56:39.000Z","updated":"2022-10-18T03:46:56.734Z","comments":true,"path":"2022/10/18/hexo/在HEXO中插入思维导图/","link":"","permalink":"http://example.com/2022/10/18/hexo/%E5%9C%A8HEXO%E4%B8%AD%E6%8F%92%E5%85%A5%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","excerpt":"","text":"markmap 无权限，安装报错使用管理员打开cmd 使用方法[掘金文档内容](Markmap 让你几行代码生成一个思维导图 - 掘金 (juejin.cn))","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"}]},{"title":"白盒和性能测试","slug":"软件测试/测试用例和性能测试","date":"2022-10-18T02:46:02.000Z","updated":"2022-10-18T03:55:51.051Z","comments":true,"path":"2022/10/18/软件测试/测试用例和性能测试/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%92%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","excerpt":"","text":"分页的写法","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"软件测试","slug":"软件测试/软件测试2022年10月18日之前","date":"2022-10-18T00:58:03.000Z","updated":"2022-10-18T01:17:45.425Z","comments":true,"path":"2022/10/18/软件测试/软件测试2022年10月18日之前/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%952022%E5%B9%B410%E6%9C%8818%E6%97%A5%E4%B9%8B%E5%89%8D/","excerpt":"","text":"2022年9月27日招聘给tomcat配置环境变量和mysql一样 如何部署网站问题没有监听8080端口原因是，JAVA_HOME路径配置错误 错误可以从 tomcat路径下面的 logs&#x2F;cataline.out 查看 命令用cat命令 image-20220927111917988 查看自己访问的端口号 image-20220927111947640 开启后的8080 是外网访问 8005 是内网 3306 数据库的 步骤就是把war包放入webapps中，然后启动tomcat 通过端口号加:8080/资源名访问 在linux中如何导入.sql文件进入mysql中导入 首先看看。sql文件的内容中是否有创建数据库和切换数据库的代码 image-20220927100132877 如果有直接就 正常登录然后使用命令 &#x2F;&#x2F; 执行source命令,可用pwd查询sql文件路径 source &#x2F;mysql&#x2F;file.sql image-20220927100627617 使用shell命令导入，导出sql文件source命令，是一行一行执行的，过慢，不适合大数据 导出数据库 直接使用命令： mysqldump -u root -p abc &gt;abc.sql 然后回车输入密码就可以了； mysqldump -u 数据库链接用户名 -p 目标数据库 &gt; 存储的文件名 文件会导出到当前目录下 导入数据库（sql文件） mysql -u 用户名 -p 数据库名 &lt; 数据库名.sql mysql -u abc -p abc &lt; abc.sql 这里的 数据库名 可以没有，就是上述的 sql文件中有创建数据库和切换数据库的代码 注意sql文件必须在当前目录下，如果不在当前目录下需要在&lt; 之后加上具体sql文件路径 image-20220927101853693 在markdown文件代码块中使用linux的代码，怎么设置无 mysql安装步骤创建用户组和用户 解压安装包 设置文件权限（不赋予权限试试） 添加my.cnf配置文件 配置my.cnf文件 添加my.cnf中的使用到的文件夹 安装mysql 添加mysql到开机初始化启动项中 添加到服务中 启动mysql 修改密码 chmod 和 chown 的用法和区别chomd和chown的作用及用法区分 详解： Linux中chown和chmod的用法 总的来说只有root用户还有文件的所有者可以该文件的对于自己和其他人的权限 为了避免文件执行时不可执行，文件读写时不可读写的问题，需要按需设置文件的权限 安装mysql报错FATAL ERROR: Could not find .&#x2F;bin&#x2F;my_print_defaults的解决办法对mysql数据库初始化过程中，会有如下报错信息： image-20220927195521784 按照报错信息，去mysql安装目录的bin目下查找是否有_print_defaults，在第一列的第七行有发现这个文件 image-20220927195532664 看来其实不是没有这个文件，不是这个问题。 认真查看报错信息，可注意到那个路径是相对路径，是以mysql的安装目录为起始。 而初始化则是进去初始化脚本目录里运行脚本，而在这个目录下不会有.&#x2F;bin&#x2F;my_print_defaults的。 所以回到安装目录以相对路径去执行初始化脚本。 image-20220927195543703 OK！初始化成功 2022年9月28日为什么有的时候tomcat的war包会自动解压，有时候又不会我试过重新启动tomcat但是依然不行 image-20220928100430760 检查配置文件 在conf&#x2F;server.xml 中 unpackWARs：自动解压 AutoDeploy：服务器不需要重启就可以解压 权限问题，当前用户是否有创建文件夹的权限 切换到root用户 总结： 是我传成sql文件了，本来是可以自动解压的。。。。。。。。 image-20220928101700460 打开网页但是显示404 image-20220928103812176 配置文件是 image-20220928103910861 按照配置文件弄好了，我用别的war包可以用，但是这个搜车网的还是不可用 结果： 顾润说是mysql的版本不匹配，比赛时用官方给的，是匹配的，不会出现这种问题，就不纠结了 linux 如何查看当前ip地址vb启动虚拟机报错 img 把网卡改成上 面一样，高级的可以不弄 虚拟机没有IP地址csdn img 发现ens33 没有inet 这个属性，那么就没法通过IP地址连接虚拟机 接着来查看ens33网卡的配置：vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 注意vi后面加空格 vi是Linux内置的文本编辑器命令 打开文件的意思 从配置清单中可以发现 CentOS 7 默认是不启动网卡的（ONBOOT&#x3D;no）。 把这一项改为YES（ONBOOT=yes） img 然后按 Esc 退出 再出入命令 :wq 再按Enter即可 （备注 :wq 是保存然后退出的意思 后面会专门讲下vi） 然后重启网络服务： sudo service network restart 然后我们再输入 ip addr 命令 img MySQL 安装的 pid 和 socket问题2022年9月29日vb网络配置 ip addr 查看没有ens33 只有enp0s3 是可以的，网卡名字不一样（10.啥的不是ip） 同样 vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-enp0s3 把ONBOT的值改成yes 然后重启网络服务 ，sudo service network restart 若发现ONBOT已将是 yes ，2就不用再做了 （好像只用第四步） 改网络设置(高级有时也不需要改)，如图 &lt;img src=&quot;image-20220929101314107.png&quot; alt=&quot;image-20220929101314107&quot; style=&quot;zoom: 80%;&quot; /&gt; 有时候新建的虚拟机不能用桥接打开，报网络错误 image-20220929131136973 把地址改成第一个，这个进去后，之后再改回来就可以了 子类覆写后调用再调用的规则 子类在初始化时，父类会先于子类初始化，而父类构造器中调用的方法又是子类覆写的方法，从而导致了父类在初始化过程中使用了错误的子类初始化数据 了解自己的思维一些自己思维的常识与代码逻辑有相通之处 2022年10月11日坚果云升级账号升级账号 :no_good_man:大咩 image-20221011093646856 首先，免费版没有空间限制，但是每个月可以上传1G 假设免费版用到的空间为8G 专业版开年费有30G的空间，每月增加1G（只有年费才有），也就是42G（12个月后） 专业版年费到期后，空间为免费版用到的流量，加上每月扩容的流量，也就是8+12 那么，多余的问价你要么删除，要么继续开通，要么在会员到期之前，全部下载下来 所以，用它来同步照片，同步大文件啥的，不合适，有百度网盘，就可以，坚果云毕竟是同步盘 总的来说，像这样，写博客，偶尔粘贴几个图片，用到office办公，文件共享之类的，每月1g，免费的同步，企业级的数据安全（比自己的nas用的硬盘好一点，我的垃圾硬盘，哈哈），我能用到天荒地老:joy: 写测试用例 2022年10月12日","categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"hexo的安装和安装遇到的问题","slug":"hexo/hexo的安装和安装遇到的问题","date":"2022-10-17T11:50:10.000Z","updated":"2022-10-20T12:02:03.863Z","comments":true,"path":"2022/10/17/hexo/hexo的安装和安装遇到的问题/","link":"","permalink":"http://example.com/2022/10/17/hexo/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"hexo 主题官方使用文档大道至简——Hexo简洁主题推荐 | 屠·城 (haomwei.com) 修改npm源\\1. W+R打开搜索，输入cmd，打开终端面板。 \\2. 输入以下命令： 1npm config set registry https://registry.npm.taobao.org \\3. 检查是否修改成功： 1npm config get registry \\4. 如果输出以下内容即为修改成功： 1https://registry.npm.taobao.org \\5. 如果未修改成功重复3、4步骤即可。 解决 hexo-renderer-sass 无法安装大概是这插件太老了，已不适用 node -v v16.15.0 ，node 12 大概是同时代版本，可自行尝试。 解决方案这插件网上一堆错误，开发者根本也不管了，好在还有其他替代方案，适用有人更新的替代版本 hexo-renderer-sass-next ： 12npm uninstall hexo-renderer-sassnpm i --save hexo-renderer-sass-next 换插件后，根本不存在网络问题，node、python 版本问题，测试下依赖 node-sass 的主题，一切都这么丝滑。 参考文档 开始新的折腾，Hexo博客Git-VPS部署完整记录 node-sass安装遇到的错误 hexo-renderer-sass-next hexo 的图片显示问题因为要发到github托管 所以使用相对路径 众所周知，在md中插入图片的语法为i[]() 其中方括号时图片的描述，圆括号为图片的路径。 使用typore复制到本地时候，图片会自动变为![](文章名/image.jpg) 使用这个配置之后，复制到文章中的图片就会自动变成![](文章名/image.jpg) hexo设置由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。 在hexo中使用文章资源文件夹需要在config.yaml文件中更改一下配置： 1post_asset_folder: true 当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。 由于项目会生成新的文件目录，同时会解析Markdown中的图片路径，会导致一个问题。如在一个文件目录下，博客名为1.md，相应的存在一个1文件夹存放图片image.jpg。在Typora编辑器中，普通的md文件使用![](1/image.jpg)能在编辑器中正常显示图片。在hexo中，按理说应该是使用![](image.jpg)，但网页中却无法正常显示。此时应该使用这样的方式来引入图片： 图片插件插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 之后就可以在使用![](image.jpg)的方式愉快的插入图片了。 我们做了这么多都是为了方便，那么为什么不再方便一点呢。 图片插件和typora结合但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的文件名/。不慌，也很简单。 在Typora编辑器中，使用&lt;C-f&gt;快捷键，将所有的文章名/替换为空即可删除 img ————-本地预览不显示图片的问题—————- 在typora的设置中选择图片工具，为文章设置一个图片根目录。设置方式如下，之后选中存放图片的目录即可，根据不同版本的typora该设置项可以能在不能的位置。 图片可以本地预览为了方便，可以在scaffolds -&gt; post中添加如下设置。 1typora-root-url: &#123;&#123; title &#125;&#125; 这样每次执行hexo new命令新建文章的时候，会在Front Matter中自动添加该配置，如下： 1typora-root-url: hexo图片显示问题 至此，在本地和服务器的图片都能正常预览。 categories和tags标签设置可以在scaffolds -&gt; post中添加如下设置。 12categories: tags： 给文章添加tags属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格- 表单验证就是这篇文章的标签了 12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 给文章添加categories属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 HELLO WORD 文档Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: [Deployment](","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"}]}],"categories":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"软件测试/性能测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"单元测试","slug":"软件测试/单元测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/categories/HEXO/"},{"name":"自动化测试","slug":"软件测试/自动化测试","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"map","slug":"map","permalink":"http://example.com/categories/map/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"性能测试","slug":"性能测试","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"name":"jmeter","slug":"jmeter","permalink":"http://example.com/tags/jmeter/"},{"name":"软件测试考点","slug":"软件测试考点","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%80%83%E7%82%B9/"},{"name":"单元测试","slug":"单元测试","permalink":"http://example.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"HEXO","slug":"HEXO","permalink":"http://example.com/tags/HEXO/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}]}